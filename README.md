# Z语言炼成记

## 介绍

Z语言是一门个人向的专注于学习和探索的编程语言。

我的设计目标是：**做世界上最强的玩具语言！**

Z语言的重心放在编程语言知识的学习和分享上。
更注重内容的广度而不是深度。麻雀虽小，五脏俱全。
别人有的我都有，但是并不多。
深度上则是由浅及深，换句话说就是我学了多深，就写多深。

Z语言最大的特色就是“面向场景编程”，且什么场景都有可能支持。

现阶段，Z支持的场景有：

- 探索式编程：解释器+REPL
- 脚本模式：`z run`
- 静态编译：`z build`可以生成Linux和Windows两个版本的可执行文件
- 后端开发：`z c`可以将Z语言转译成C语言，嵌入到任意C生态。
- 科学计算和AI：`z py`可以将Z语言转译成Python，嵌入到任意Python生态。
- 前端开发：`z js`可以将Z语言转译成JavaScript，嵌入到任意JS生态。

Z语言的实现放在<https://gitee.com/z-lang/zc>工程里。

《Z语言炼成记》这本书是Z语言实现的配套书籍，
我会把设计和开发过程中的点点滴滴都记录下来。
用这种方式来记录，希望能够提供更真切的“临场感”。

虽然本书分了章节，但每一节基本可以算做是一篇日志。
我每做出一点新功能，就就更新一节，并打上一个tag。

每个tag都尽量保测试通过，可以运行；如果后来发现问题，会打相应的补丁tag。

关于Z语言本身的介绍，可以参看引言中的[“Z语言是什么”](./Z语言是什么.md)一节。

## 目录

#### 引言

- [Z语言是什么](./Z语言是什么.md)。

#### 第一章：基本框架

1. [最简单的Z程序](./第一章/最简单的Z程序.md)。
1. [最简单的编译器 - Windows版](./第一章/最简单的编译器Windows版.md)。
1. [最简单的编译器 - Linux版](./第一章/最简单的编译器.md)。
1. [最简单的转译器](./第一章/最简单的转译器.md)。
1. [最简单的交互器](./第一章/REPL.md)。
1. [组织代码结构](./第一章/组织代码结构.md)。
1. [自动测试](./第一章/自动测试.md)。

#### 第二章：算数运算

1. [整数](./第二章/整数.md)。
1. [词法分析](./第二章/词法分析.md)。
1. [加法](./第二章/加法.md)。
1. [四则运算](./第二章/四则运算.md)。
1. [优先级](./第二章/优先级.md)。
1. [括号与负数](./第二章/括号与负数.md)。

#### 第三章：函数

1. [函数初探](./第三章/函数初探.md)。
1. [内置函数](./第三章/内置函数.md)。
1. [Z标准库](./第三章/Z标准库.md)。
1. [编译器调用](./第三章/编译器调用.md)。
1. [转译器调用](./第三章/转译器调用.md)。
1. [多条语句](./第三章/多条语句.md)。
1. [第三方库](./第三章/第三方库.md)。

#### 第四章：存量和语句

1. [存量](./第四章/存量.md)。
1. [哈希表](./第四章/哈希表.md)。
1. [定量](./第四章/定量.md)。
1. [布尔类型](./第四章/布尔类型.md)。
1. [条件语句](./第四章/条件语句.md)。
1. [变量与赋值](./第四章/变量与赋值.md)。
1. [循环语句](./第四章/循环语句.md)。

#### 第五章：视野

1. [新视野](./第五章/新视野.md)。
1. [代码块](./第五章/代码块.md)。
1. [语句](./第五章/语句.md)。
1. [自定义函数](./第五章/自定义函数.md)。
1. [自定义类型](./第五章/自定义类型.md)。
1. [模块](./第五章/模块.md)。
1. [库](./第五章/库.md)。
1. [场景](./第五章/场景.md)。
1. [生态](./第五章/生态.md)。

#### 第六章：复合类型

1. [数组](./第六章/数组.md)。

#### 第七章：类型初探


#### 附录

- [参考资料](./参考资料.md)。

## 短期规划

#### 2023年12月目标：

- 用例：
    - Python：Numpy库的基本支持；
    - JS：WebGPU的基本探索；
- 书：完成5~6章。分别是：视野与复合类型。具体需求跟随《AI图形引擎》的进度。
- 语言：完成v0.1版。重点：视野、复合类型（数组、字典）、自定义函数、自定义类型、模块化。
- 工具链：
    - 完善REPL，支持Z/Python/JS模块的导入和脚本的调用。
    - 初步探讨LSP和vscode的插件。实现一个颜色高亮插件。

#### 2023年11月目标：

- 书：写完前四章。第五章写一半，实现基本的面向对象：类型、方法和简单继承。
- Z语言：实现v0.1版，一个可用的玩具语言，同时支持动态解释、静态编译，还能够转译成C、Python和JavaScript。

结果：
- 书：写完了前4章。第五章还没开始写。原先预计的内容现在发现有7~8章左右。
- Z语言：实现了从基础到函数、语句等大部分功能。但没能实现类型、方法和较复杂的自定义函数。

## 特性规划

Z语言v0.1版包括如下内容：

### 语言特性：
- [x] print
- [x] 字符串常量
- [x] 整数
- [x] 算数运算
- [x] 内置函数
- [x] 外部函数调用
- [x] 标准库雏形
- [x] 多条语句
- [ ] 自定义函数
- [x] 定量
- [x] 布尔类型
- [x] 比较运算
- [x] if语句
- [x] for循环
- [ ] when分支
- [ ] 常量
- [x] 变量
- [ ] 幻量
- [ ] 视野
- [ ] 递归函数
- [ ] 基本模块化
- [ ] 自定义类型
- [ ] 方法
- [ ] 动态类型any
- [ ] 编译期函数调用

#### 工具链：

- 解释器：zi
- 编译器：zc
    - gas: GNU X86_64汇编
    - masm64: Microsoft Assembly 64bit
- 转译器：
    - z2c
    - z2py
    - z2js
- REPL：zir
- run：z run

## 中长期规划 

### 第一册：基础

#### 第一章：基本框架

1. ~~Hello world~~
1. ~~解释器~~
1. ~~编译器~~
1. ~~REPL~~
1. ~~转译器：C~~
1. ~~转译器：Python~~
1. ~~转译器：JS~~
1. ~~基本函数~~

#### 第二章：基本运算

1. ~~整数~~
1. ~~加法~~
1. ~~减法~~
1. ~~括号~~
1. ~~乘除法~~
1. ~~单元测试~~
1. 浮点数
1. 自定义函数`pow(m, n)`

#### 第三章：函数

1. ~~函数初探~~
1. ~~REPL与内置函数~~
1. ~~Z标准库~~
1. ~~编译器调用~~
1. ~~转译器调用~~
1. ~~多条语句~~
1. ~~脚本模式与第三方库~~
1. 自定义函数


#### 第四章：存量和语句

1. ~~存量~~
1. ~~逻辑类型~~
1. 代码块
1. 条件语句
1. 循环语句
1. 分支语句
1. 复合表达式
1. 注释

#### 第五章：复合类型

1. 数组
1. 方法初探
1. 哈希
1. 字符串
1. 字典
1. 元组
1. 浮点数
1. 向量
1. 矩阵
1. 自定义类型
1. JSON
1. 模块化

#### 第六章：面向对象

1. 类
1. 方法
1. 接口
1. 组合
1. 隐私
1. 继承
1. 多态
1. 反射

#### 第七章：完善基本类型

1. 其他整数
1. 比特
1. UTF8
1. 中文字符串
1. 中文名称
1. 内嵌字符串

### 第二册：生态

#### 第八章：函数进阶

1. 完整函数
1. 匿名函数
1. 可变参数
1. Lambda
1. 闭包
1. 函数多态
1. 编译期函数
1. 函数式编程
1. 算法

#### 第九章：改进标准库

1. Math
1. IO
1. Net
1. Thread
1. Http
1. 面向场景编程`SOP`

#### 第十章：高阶特性

1. 异步
1. Coroutine
1. 生成器
1. 编译期脚本
1. 泛型
1. 宏
1. 静态反射
1. 动态反射
1. 代码生成
1. DSL

#### 第十一章：内存管理

1. 手动内存管理（malloc/free）
1. 引用计数
1. 垃圾回收
1. 内存池
1. 弱引用和借用
1. 生命周期管理
1. 自动引用计数（ARC）
1. 自动内存释放（Auto Free）

#### 第十二章：跨语言

1. FFI：C
1. FFI：Python
1. FFI：JS
1. Binding: C
1. Binding: Python
1. Binding: JS
1. c2z
1. py2z
1. js2z
1. bash2z
1. 跨语言REPL

#### 第十三章：完善工具链

1. 测试框架
1. 性能工具
1. zb: Z Builder
1. 包管理，repo
1. LSP/IDE插件
1. 社区工具

#### 第十四章：优化

1. AST优化
1. IR
1. SSA
1. Passes
1. JIT

#### 第十五章：打通生态

C生态:

1. HTTP服务
1. redis/数据库访问
1. 图形库
1. GUI库
1. 游戏引擎
1. 多媒体库

Python生态:

1. numpy
1. plot
1. pandas
1. tensorflow
1. pytorch
1. Stable Diffusion

JS生态:

1. 前端GUI（vuejs）
1. wasm
1. webgpu
1. vscode

#### 第十六章：应用展示

1. REPL：zcalc，带有记忆功能的可编程计算器。
1. 编译器：用FFI的形式，调用C语言的库，实现一个最简单的HTTP服务。
1. 转译C：调用SDL库，实现一个最简单的2D游戏，并借用Emscripten转译成WASM。
1. 转译Python：调用pyplot库，绘制一个K线图。
1. 转译JavaScript：调用vuejs库，实现一个最简单的前端页面，并展示上面两个成果。

### 第三册：应用

如果能做到这个地步，Z语言应当已经比较成熟，且打通了C/Python/JS的生态，拥有了完整的应用库了。

这时候就可以开始实现我最初的梦想了：用Z语言开发自己的应用。

我大致有如下几个方向的设想：

1. Zap（Z App Platform），前后端开发无缝链接的UI框架。需要打通C/JS生态。
1. Zeco (Z Editor for Coders)，类似于VSCode的通用编辑器，也是Z语言的官方IDE。主要基于C生态；但还需要实现一个WEB版，因此也需要JS。
1. Zire（Z Interactive REPL Environment），融合bash、python、js的交互环境，提供一站式探索式编程的交互环境。需要打通C/Python生态。
1. Zif (Z Image Fusion)，基于Stable Diffusion的图像处理工具。主要基于Python生态，再加上基于JS的界面。
1. Zaivre（Z AI Virtual Reality Engine，可以读作zavor，/ˈzeɪvə/）, AI虚境引擎。需要C/Python/JS。

Zaivre虚境引擎是我的最终目标，也是我学习并开发Z语言的初衷。
这个引擎需要同时打通C/Python/JS的生态，所以我才会选择它们作为Z语言的目标语言。

这些项目没一个好对付的，所以现在只是一个构思，一个方向，具体怎么做到时候再说，至少要等第二册写好了，Z的基本库都能用了再仔细探讨吧。
