# 模块

Z语言的模块组织方式和Python类似：

- 默认情况下，一个文件就是一个单独的模块。
- 一个目录下多个文件，可以组成一个更高层级的模块，目录名就是模块名。目录下的`{目录名}.z`文件是目录模块的入口文件，和Python的`__init__.py`类似。
- 多个目录也可组成更高层级的模块，同样以目录名作为模块名，以`{目录名}.z`文件作为入口文件。

例如，一个典型的复杂模块如下所示：

```
- http/
    - http.z
    - server/
        - server.z
    - client/
        - client.z
        - sync.z
        - async.z
```

这里的`http`模块有两个子模块，分别是`http.server`和`http.client`，
其中`http.client`又包含了`http.client.sync`和`http.client.async`两个子模块。

作为入口文件，`http/http.z`可以做两个事情：

- 为`http`模块提供全局的存量、类型和函数。
- 引用`http.server`和`http.client`两个子模块的内容，并选择性地开放出来。

我们本节先实现最简单的模块功能，即文件级别的模块声明和引用。

## 模块文件

默认情况下，一个文件就是一个单独的模块，而文件名就是模块名。
这时候，并不需要做任何声明，直接在模块文件中写代码即可。

模块文件中的代码可以分为几类：

- 全局存量的声明及定义
- 函数的声明及定义
- 类型的声明及定义
- 对其他模块的引用
- 全局脚本代码

举个例子：

```c
// http.z

// 对其他模块的引用
use server.*

pub use server.Server // 这样就可以直接用http.Server了

// 全局存量的定义
const DEFAULT_PORT = 80;

// 函数
fn serve(port int = DEFAULT_PORT) {
    // 具体的实现
    // ...
}

// 类型
type Request {
    // ...
}

// 全局脚本代码
// 注：类似http这样的库函数模块，不允许直接写下全局脚本代码
```

每个模块都有自己的视野，模块内定义的名称，只在模块内有效，
而其他模块想要用它们，必须想办法导入名称，或者引用模块的视野。

假设我们写好了这样一个模块，具体怎么用呢？

在我们自己的`app.z`中，可以这样调用模块内的功能：

```c
// app.z
use http

let server = http.serve(8080)
server.on({
    "/": (req http.Request) => {
        // ...
    },
    "/login": (req http.Request) => {
        // ...
    }
})
server.start()
```

注：上面的例子只是我为模块化临时想的示例，并不代表将来Z的http模块会这么实现。

这里的关键语句就是`use http`：

- `use`关键字类似于`include`、`import`
- `use http`的意思是引入`http`模块的视野，该模块内的所有内容都可以通过`http.`前缀来访问，例如`http.Request`。

当然，用`http.Request`肯定不如直接用`Request`方便，
因此在不引起歧义的情况下，
Z在“脚本”和“应用”场景里允许直接使用模块内的内容：

```c
use http

serve(8080).on({
    "/": (req Request) => {
        // ...
    },
    "/login": (req Request) => {
        // ...
    }
}).start()
```

要实现这种名字查找，编译器需要做如下工作：

- 现在当前视野中查找名符
- 如果找不到，就到更大的视野中查找
- 如果还找不到，就到本模块引用过的模块中查找

例如，上面的例子中，`Request`名称：

1. 在本模块中并未定义，所以第一步查找失败
1. 然后在全局模块中查找（例如全局内置名称），也找不到
1. 最后，尝试在`use`的`http`模块中查找，找到了`http.Request`。
1. 因此，本模块中所有的`Request`都被替换为`http.Request`。

在这种查找模式下，如果遇到了歧义的情况，例如两个引入模块中均存在`Request`，那么编译器会报错。（注：也可以找到第一个就停止，这样就不会报错了，但容易引起混乱，暂不考虑）。

本节暂时不考虑这个问题，而是先实现最基础的`use http`引用语法和`http.Request`这样的标准用法。

## 模块与视野

对于编译器而言，这相当于在名称查找的过程中添加一个新的查找源。

Z语言添加了模块概念之后，我们之前所说的“全局视野”，实际上是一个模块内部的全局视野，在其他模块中是不可见的。

所以我们在解析源码文件，并构建`scope`对象时，需要把原先的`GlobalScope`改成`ModScope`，并扩充视野的组织形式，让编译器可以在多个模块之间进行名称查找。

考虑到模块本身也是可以分层的，因此，所有的视野形成了一颗层级更深的视野树。

要实现这样的结构，首先得修改编译器的解析结构，让它能支持多个文件的解析。每个文件的解析结果，不再是之前的`ND_PROG`，而是一个`ND_MOD`为根的AST树。

例如，我们把之前的`fn_add`用例拆成两个模块，一个是`math`模块，另一个是`app`模块：

```c
// math.z
fn add(a, b) {
    a + b
}
// app.z
use math
math.add(1, 2)
```

## `use`语句

`use`语句的关键作用就是引入一个新的视野。
引入一个模块之后，就可以通过`模块名.`前缀来访问模块内的内容了。

我们先实现最简单的`use`，即`use <module-name>`，这种最基本的形式。