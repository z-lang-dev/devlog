# 新视野

今天（23年12月1日）初生的Z语言发生了一件大事：我要出版书了！

当然，要初版的并不是这一本《Z语言炼成记》，而是时下的热门话题：AI和元宇宙。

具体来说，是一本名为《从零开始实现AI图形引擎》的书，
它的主题是AI绘图和图形引擎。

## AI图形引擎的新视野

AI绘图功能基本是Python的天下。而图形引擎可以用C实现（OpenGL/Vulkan/DirectX），
也可以用Javascript实现（WebGL/WebGPU）。

和编辑商量之后，我费尽心思把Z语言塞进去了，作为其中一种实现语言。
这样，Z语言也算是第一次有了用武之地了！

但现在AI行业真的是日新月异，我要写这本书，就必须**尽快**做出来。
否则初版之日，就是过时之日。
不论是AI绘图，还是图形引擎，都不是轻而易举能做出来的东西。
更何况我还不熟。我上大学学AI的时候，还没有深度学习呢！
一切都得重新学过。

所以必须想办法尽快做出一个能跑的版本。
借助现有的生态，也是必须的了。
而且也没法什么都介绍，只能挑重点。

为了足够快，我决定暂时抛弃用Z调用C来做引擎。
原因很简单，这个事情是最难的。
现有的几大图形引擎（Unreal、Unity、Godot），都是用C++开发的。
Z要用来做图形引擎，必须模拟出C++的面向对象特性，或者干脆就直接翻译成C++。
前者非常麻烦，后者我不愿意。
所以干脆延后吧。反正翻译成JS也能做引擎。

然后JS那头，我打算只选一个基础库，就是WebGPU，然后基于它选择一个开源的图形引擎作为研究对象。

我打算，把这本书的主题写成“帮读者剖析现有的AI绘图技术和图形引擎是怎么一步步做出来的”。
而不是“我自己从零开始完全实现一个新的AI模型，再实现一个新的图形引擎”。
那太不现实了。

整本书分成三个部分：

1. 从零开始介绍Python生态的AI绘图技术
1. 从零开始介绍Javascript/WebGPU生态的图形引擎技术 
1. 用Z把这两套技术缝合起来，形成一个能用AI生成资源素材的图形引擎

所以，Z在这个主题里所扮演的角色，就是“胶水代码”，是“融会贯通”的融合剂。

这样一来，既不会太难实现，也没有喧宾夺主的感觉。正好可以体现Z的特点。

不过如此一来，之前规划的Z语言的开发计划，就要大规模修改了。

## Z语言的新视野

在《AI图形引擎》这本书完成之前，Z语言的角色都是配合开发。因此需要尽量削减自身的开销。

首先，我打算大刀阔斧地做减法：

1. 直接砍掉汇编输出。汇编输出本来就是我拿来学习编译器技术的工具，最开头就没打算用来做严肃的开发，Z未来如果要用于真正的项目开发，应该是类似V语言那样通过翻译成C来执行。更何况汇编输出一直是Z语言六大输出中最难的两个，平均要花一半时间。
1. 由于出版的书决定用JS开发图形引擎，所有C的输出都暂停。不过考虑到C的输出相对比较容易，有空的话也可以补一补。
1. 语言特性的补全，不再依照之前按部就班的规划，而是改为“应用驱动”。即我先用Python或C写出引擎的实际代码，再考虑如何用Z来实现转译。根据具体的需求，规划如何补充语言特性。例如，通过今天的调查我发现Python机器学习的核心是“张量”，即`tensor`或`ndarray`，那么Z语言就要尽早加上对张量的支持，进而要求首先要实现数组。这样数组的优先级就提高了。
1. 创作的节奏，即“主要矛盾”，改为《AI图形引擎》一书。我的思路都优先放到那本书去，然后根据需要更新Z语言编译器，进而更新《Z语言炼成记》这本书。

总而言之，《Z语言炼成记》这本书经过1个月的高速开发，要转进成“缓行模式”了。
也就是说，Z语言和《炼成记》很难再保持每天一更新的节奏了。
但我不会放弃Z，因为还要实现“天下第一玩具语言”的梦想呢！

最后回到“新视野”这个话题。

说来也巧，我第五章脱离了原定的节奏，开了“视野”的话题，除了要实现Z的视野功能（即“作用域”）之外，
本就想先前瞻一下Z未来的发展方向，以及我从现在的角度能看到什么样的“视野”。

现在看来，其实不过把某些未来的计划提前了：Z一开始的目标，就是“三大生态”：

- AI
- 虚境
- 机器人

这三个生态是我这几年观察后得出的结论，是我认为未来十年内可以改变整个世界历史走向的三大领域。
我们生活在一个风起云涌的大时代，而这三大技术结合起来，正是狂风巨浪，是滚滚大潮，是翻天覆地的变革。

我前年翻译了《深度学习与围棋》一书，讲述的是AlphaGo，早就对AI技术有所感触；
去啊年调研了单片机和简单的机器人技术，曾经想要实现一套适合机器人的操作系统，这也是我最初给Z语言的定位：做真正的“better C”，替代现在C在嵌入式领域的地位;
今年又研究了游戏引擎，尤其是Godot。
最近半年，ChatGPT引领了AI技术的大爆发，我终于算是找到了具体的努力方向：AI+引擎；机器人作为“战未来”的方案。

而上个月开始写《Z语言炼成记》这本书，真正立下了现在Z的架构，也是为了实现这个目标：让Z语言成为AI、虚境、机器人三大生态的“胶水”。

- AI生态绕不过Python，现有的几乎一切AI成果，都是在Python生态出的。
- 虚境技术几乎是C/C++的天下；但随着WebGPU的出现，JS也在逐渐崛起。
- 机器人相关的生态，尤其是嵌入式系统的开发，基本是C语言的自留地。

再加上我自身对编译器技术足够感兴趣，所以Z就定下了六个输出目标：

- C/Python/JS，这是“外功”，借助现有的生态，化身融合的桥梁，创造真正能玩的玩具。
- 解释器/Windows汇编/Linux汇编，这是“内功”，提高Z本身的实力，为未来成长为成熟的编程语言打下基础。

我计划的第一年都是学习为主，所以可以看到，前四章的重点都放在“内功”上，C/Python/JS的输出仿佛只是个附带。等Z语言自身差不多特性完备了，再去建设功能库和生态链的时候，就是“外功”发挥力量的时候了。

但这些计划最终都是为了实现“三大生态”融合的目标。

因此，既然现在就有机会出版《AI图形引擎》这本书，那对Z语言来说当然是好事！
揠苗助长，也是生长啊！

所以，我觉得《AI图形引擎》这本书不但没有拖Z语言的后腿，反而是千载难逢的机会。
真正的应用，真正的引擎，会拉着Z语言马不停蹄地向前奔去！

这，就是Z语言面临的前景，是我所看到的新视野。

所以请读者明白，即使接下来半年到一年，Z语言的更新速度仿佛变慢了，《炼成记》这本书仿佛变得零零碎碎了，
这些都不是问题，因为《AI图形引擎》一书完成的时候，Z语言的特性就会完全追上Python和JS了，

那时候，Z已经完成了从初生牛犊到成熟的玩具语言的蜕变。

那时候，再来补全C语言输出、补全汇编语言，甚至增加新的输出（例如我考虑过明年增加龙芯架构的输出，和鸿蒙ArkTS的转译），都不是问题了！那时候，Z语言就真正走上了追逐“天下第一玩具语言”的舞台！

## Z语言的“视野”特性

好的，梦想的话说足够多了，现在回到Z语言的现实。

我们已经实现了好几个寄出的语言特性，但由于没有支持“作用域”，所以这些特性都是“全局”的。
这样显然做不了太多有用的事情。
甚至自定义函数和自定义类型，都要求必须有独属于自己的“地盘”。

英文里，作用域这个词是“scope”，我觉得翻译成“视野”更好。
并且，Z语言里的“scope”，还有比传统语言的`scope`更多的设计（例如参与生命周期管理），
所以我专门为Z取了“视野”这个名字。

要是不习惯这个新名字（就像我之前取的“定量”“存量”之类），那么直接读作“scope”，也不影响理解。

那么为什么要用一整章来讲“视野”这一个特性呢？
因为它在Z语言里和函数、类型一样，都是第一等的核心特性。

`视野`特性至少与如下几个特性有关：

- 复合语句：语句块或`if-else`等语句，都有自己独立的视野
- 函数：函数的局部存量和参数，与函数的视野所绑定。
- 类型：类型的成员变量，与类的野所绑定。类的方法和继承都要与视野特性配合。
- 模块：模块的视野，类似于C++的名字空间。
- 库：每个库都需要提供自己API。
- 生命周期：局部存量、堆存量的生命周期管理，离不开视野的支持。
- 场景：场景也是一种特殊的视野，它也决定了某些库、甚至某些特性是否可见。
- 生态：各个生态如何交互，如何定义交叉的场景，也有一个“生态视野”的概念。

总的来说，`视野`从于最细的语言粒度（存量/表达式）到最广的粒度（库/场景），几乎无所不在。

因此，以`视野`的概念作为线索，展开对Z语言整体设计的巡礼，是非常合适的。

本来第5章只是第4章的继续，主题是“自定义函数”和“自定义类型”，但我经过一个月的高强度开发后，
需要暂停下来总结和思考一下，因此才单独插入了一章“视野”，来进行总结和规划。

有了局部的`视野`，函数的参数和局部存量就有了意义，接着实现自定义函数就很自然了。
所以本节在实现了`视野`之后，也顺便把`自定义函数`解决，就不用单独再搞一章“函数进阶”了。

真正的“函数进阶”需要完善其他语法特性之后，才能详细探讨。
到时候的主要话题就是“函数式编程”、“协程”、“异步”之类的高阶抽象话题了。

接下来我们看看Z语言的`视野`特性到底是什么。

定义：所谓`视野`，就是对任意语言对象，定义能不能“看见”它、使用它的范围的规则。

用通俗的话说：只要是“视野”之内的物体，都能取而用之。

这里有个推论，一个语言对象，一旦跳出了所有人的视野之外，就相当于不存在了。这正是`视野`和`生命周期`建立关联的关键。

下面我们先在编译器里定义`视野`（`scope`）的通用概念，然后再从小到大的范围，讨论不同语言实体的`视野`如何实现。

## 视野的定义

我们其实已经见过最原始的`视野`了，那就是存放存量的`哈希表`。

我们的哈希表，实际上是一个`全局视野`（`global scope`）。
它的特点是：1，所有地方都能`看到`它；2，它从程序开始就存在，一直到程序结束才结束。

这两个特点，就是视野的两大属性：

- 空间属性，即`看得见`的范围
- 时间属性，即`存在`的时间

在编译器里，这两个属性并没有直接展示出来，而是以不同的形式来体现：

- 空间属性，通过树状的`视野`树的组织来实现。
- 时间属性，通过生命周期管理来体现，这里主要是通过函数的开始和节数来体现，未来还会引入线程、进程和协程。

未来我考虑把视野的时间属性也做出来，而不是像其他语言那样只是隐含在程序结构的背后。
但就目前而言，只需要把空间上的树状机构做出来就行了。

现在的全局视野，实际上就是整个视野树的根节点。
视野树的结构是从全局节点向下分散出各个子节点，如图所示。

TODO: 视野树的结构图。


那么每个节点都有哪些内容呢？

第一个，就是用来查询名称的哈希表。
每一层视野，都应该有自己独立的哈希表，用来查询它所包含的名称。
这也是“名字空间”的由来。

第二个，是存量的元信息，也就是meta表。

我们的meta表和名字表现在是分开的，一个在`meta.h`中，另一个定义在`interp.c`中，
因为它们一个是编译期的元信息，另一个是运行时的动态值。

不过，不论是编译期还是运行时，各个名称对应的`视野`都是一样的树状结构，
也就是说，每个元信息表和每个名称表是一一对应的。

这俩应该放在一起，或者至少应该有显示的一对一关系。

我打算把它们放在一起，反正元信息本来就应该续存到运行时，以方便各种反射查询。

第三个属性，是当前视野和其他视野的关系，即父子节点的链接。

和AST树不同的是，视野树往往需要从分支节点向父节点方向寻找，直到最顶层的全局视野。
这是因为更高层的`视野`对底层的应该是可见的。
所以我们需要在每个视野节点里，都记录下它的父节点的指针。

于是，就有了如下的结构。

```c
typedef struct Scope Scope;
struct Scope {
    HashTable *names; // 名称表
    HashTable *metas; // 元信息表
    Scope *parent;  // 父节点
};
```

我们先用这个结构体来替换现有的两个哈希表，其他逻辑都不变。

也就是说，现在仍然只有一个“全局视野”，但已经不是直接访问全局的哈希表了，而是通过`Scope`提供的函数来访问。

我们在`meta.h`里添加如下内容：

```c
// meta.h
struct Scope {
    HashTable *metas; // 元信息表
    HashTable *values; // 运行时存值表
    Scope *parent;  // 父节点
    int cur_seq;
    int cur_offset;
};

Scope *GlobalScope; // 全局视野

Meta *new_meta(Node *expr);
Scope *new_scope(Scope *parent);

// 从scope中向上查找
Meta *scope_lookup(Scope *scope, const char *name);
// 向scope添加一个名称
bool scope_set(Scope *scope, const char *name, Meta *meta);

// 从全局视野中查找
Meta *global_get(const char *name);
// 向全局视野添加一个名称
bool global_set(const char *name, Meta *meta);

Scope *global_scope();
```

他们的实现并不复杂，我就先不贴出来了。

注意，这里的`scope_lookup`已经实现了向上层视野查找的功能：

```c
Meta *scope_lookup(Scope *scope, const char *name) {
    Meta *meta = hash_get(scope->metas, name);
    if (meta) {
        return meta;
    }
    // 递归到上层视野中寻找
    if (scope->parent) {
        return scope_lookup(scope->parent, name);
    }
    return NULL;
}
```

也就是说，我们现在已经可以尝试实现最简单的`多层视野`了。

不过在这之前，我们先尝试把全局哈希表替换成全局视野。

第一步， 在`meta.c`中，去掉之前的`META_TABLE`，改为用`GlobalScope->metas`来访问。
这样之前的`get_meta`和`set_meta`就可以改为`scope_lookup`和`scope_set`了。
然后把整个工程中所有用到`set_meta`和`get_meta`的地方，都改成`scope_lookup`和`scope_set`。

第二步，在`interp.c`中，把之前的`set_val`和`get_val`的实现，由读写全局的`table`，改为读写`global_scope()->values`。

第三步，在`parser.c`中，解析到`let`或`mut`时，需要新建一个`meta`，并加入到视野中去：

```c
// `let()`和`mut()`两个函数都调用这个
static void do_meta(Parser *parser, Node *expr) {
    Meta *m = new_meta(expr);
    m->name = expr->as.asn.name->as.str;
    scope_set(parser->scope, m->name, m);
    expr->meta = m;
}
```

而在遇到`name()`节点时，需要多加一步查找判断，以确保当前出现的名称，确实是在视野中能查到的，
也就是已经被定义的，否则报错。

```c
static Node *name(Parser *parser) {
    Node *node = new_node(ND_NAME);
    node->as.str = get_text(parser);
    advance(parser);
    // scope lookup
    Meta *m = scope_lookup(parser->scope, node->as.str);
    if (m == NULL) {
        printf("Unknown name: %s\n", node->as.str);
        exit(1);
    }
    node->meta = m;
    return node;
}
```

这里遇到一个问题，那就是函数调用时，第一个解析的也是个`ND_NAME`节点，但它不是变量名，而是函数名。

现在虽然还没有实现自定义函数，不过马上就要做了，所以我打算一起处理。
现在的办法，是先做一个假的“函数定义”加入视野的操作，假装用到的函数是已经定义好的。

我们修改一下`interp.c`、`compiler.c`和`transpiler.c`，在`parse`之前，
加上所有全局函数的声明。因为现在只需要名称，所以我们的这个声明并不需要复杂的逻辑，只需要能把一个带名称的`meta`对象存入到视野中就行。

```c
Meta *new_builtin(char *name) {
    Node *fn = new_node(ND_FN);
    fn->as.str = name;
    return new_meta(fn);
}

void make_builtins(Scope *scope) {
    global_set("print", new_builtin("print"));
    global_set("pwd", new_builtin("pwd"));
    global_set("ls", new_builtin("ls"));
    global_set("cd", new_builtin("cd"));
    global_set("cat", new_builtin("cat"));
}

Meta *new_stdfn(char *name) {
    Node *fn = new_node(ND_FN);
    fn->as.str = name;
    Meta *m = new_meta(fn);
    m->name = name;
    m->kind = MT_FN;
    return m;
}

void use_stdz(Scope *scope) {
   global_set("read_file", new_stdfn("read_file"));
   global_set("write_file", new_stdfn("write_file"));
}
```

这几段代码都是装样子的，等实现了真正的自定义函数，我再来好好实现他们。
有了这几个函数，`parser`在遇到函数名称时，就不会抱怨“`Unknown name`”了。


最后，我们再试试最简单的多层视野：代码块视野。

在一个代码块开始时，新建一层视野（即`enter_scope`），代码块结束时，退回到上一层视野（即`exit_scope`）。

```c
static Node *block(Parser *parser) {
    expect(parser, TK_LBRACE);
    // 新建一层视野
    enter_scope(parser);
    Node *block = new_block();
    while (!match(parser, TK_RBRACE)) {
        append_expr(block, expression(parser));
        expect_eob(parser);
    }
    expect(parser, TK_RBRACE);
    // 退回上层视野
    exit_scope(parser);
    return block;
}
```

这两个函数的实现也很简单：

```c
static void enter_scope(Parser *parser) {
    // 新建一个视野，它的父节点就是当前的视野
    Scope *scope = new_scope(parser->scope);
    // 把解析器的当前视野改成新的视野
    parser->scope = scope;
}

static void exit_scope(Parser *parser) {
    // 把解析器的当前视野恢复成父节点视野
    parser->scope = parser->scope->parent;
}
```

这样，配合`name()`节点中的`scope_lookup`查找，就能实现基本的代码块级别的视野分层了。

例如，下面的代码是错误的：

```c
mut a = 1
{
    mut b = a + 1
    print(b)
}
b = 3 // Error: Unknown name: b
```

这里变量`b`是在代码块里面定义的，因此离开了代码块之后，`b = 3`这个语句里就找不到`b`了。

## 小结

至此，我们已经有了最基本的视野功能了。

这次修改涉及到好几个地方，因此要把测试全部跑通，也是花了一些功夫的。
最后我全搞定的时候，发现主要的问题还是来自于`hashtable`的具体实现，以及全局函数的准备问题。

这一节并没有引入新的语法，所以整个测试用例不做改变。

我们提交一个小版本：

```bash
$ git commit -a -m "步骤34：用全局视野替代全局哈希表"
$ git tag -a v0.0.34 -m "步骤34：用全局视野替代全局哈希表"
$ git push
```

下一节，我们有了多层视野的框架，就可以着手来实现期盼已久的功能——`自定义函数`了！
