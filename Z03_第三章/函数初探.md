# 函数初探

## 前言

如果把《Z语言炼成记》比作一套大餐的话，那么前两章的内容算是开胃小菜。

第一章，Hello World，如题所示，只是打个招呼而已；最多算是搭好了工程架子，各位就做。
第二章，基本计算器，算是初步实现了编译器最基础的功能：词法分析、语法分析，以及各个后端，有了基本表达式的支持，算是一道可口的小菜。

从这一章开始，我们将深入编程语言的核心，讲述比较严肃的内容了。

编程语言的核心，有两个概念：**数据**与**操作**。程序的本质，就是对数据进行种种操作，并得到最终结果。

第一章所介绍的整数和字符串，就是最基本的**数据**类型，后面我们还会涉及更多的基本数据类型，以及更复杂的核心概念之一：**自定义类型**。

而第二章所讲的四则运算表达式，就是最基本的**操作**了。多个表达式的组合，就是**语句**，而一组语句拼起来，再加上对输入的数据（即**参数**）和输出的结果（即**返回值**）的说明，合起来就叫做**函数**。

由于函数本身就带有输入数据和输出结果的说明，又包含了具体操作的实现，所以可以说**函数**是编程语言中最核心的概念。

按照由浅入深的原则，一般来说，编程语言的书籍都会按照抽象度从低到高的顺序来介绍语言特性：

1. 基本数据（例如整数）
1. 变量（基本数据的代名词）
1. 表达式（操作基本数据的方式）
1. 语句（如if-else等，可以组合表达式）
1. 函数（语句与表达式的组合）
1. 类型（数据与行为的组合；类型的方法其实就是一种特殊的函数）
1. 泛型（更加抽象的类型）
1. 模块（相似功能的数据与行为打个包）
1. 库（一组模块的集合）

前面的第一章和第二章基本是按照这个逻辑来介绍的。

按照这个顺序，第三章应该介绍变量或者语句了。原先我也是这么规划的。

那么为什么真来写的时候，我把函数的探讨提前了呢？

## 为什么先讨论函数

其实我们在第一章已经见过最简单的函数：`print`了。

那为什么要单独拿出一整章来讲函数呢？而且是这么早？

因为它值得。

上面已经说了，函数是编程语言里最核心的概念，这是原因之一。
但这也不是提前介绍的原因啊，因为组成函数的基本单位：变量和语句，我们还没讲呢。

我要提前介绍函数，再回过头来讲变量和语句，
最主要的原因，在于函数的**实用性**。

我们学习编程，是拿来用的。
我设计Z语言，也是拿来用的。
这是本书的基本宗旨。

所以回头一看，前两章虽然涉及了很多东西，但若说实用，其实只做了两件简单的事情：

- 在命令行打印一条消息
- 进行简单的四则运算

这够吗？这不够。

即使作为开胃小菜，它们的味道也太寡淡了。

既然本章起要进入正餐流程了，那么第一道主菜，一定是要有味道的！

对于编程语言来说，什么叫能看得见闻得着的味道？那就是**应用**。

我们需要能真正肉眼看到的，跑起来的应用，最好是图形化的。

只有变量和语句，能做到这一点吗？能画出图来吗？能打开窗口吗？能写下文件吗？能跑起小人吗？能生成AI图吗？
都不能。

那谁才能做到这一点呢？非**函数**莫属。

函数是编程语言的积木块，是各种程序系统沟通的基本单位：

- 要和操作系统进行沟通，必须要掌握“系统调用”，即操作系统提供的一组关键函数。
- 标准库的核心，也是各个库的函数。我们称之为“函数接口”。
- 跨系统之间的沟通，都是通过“API”来表达的，而API就是一组函数。
- 任何WEB或app界面，用户的每一次点击，实际上都是远程（通过HTTP协议）调用了一个函数。
- AI的神经网络，本质上也是一个巨大的函数。

总之，函数是程序的基本工具，是所谓“语言生态”的基本单元。

即使现在没有变量、没有语句，但我们如果有了最基本的函数，也能通过`调用`的方式，借用系统库，或者Python和JS的库，来实现相对复杂的功能了。

这样，Z语言就能尽早“实用”起来。

本章我们要做到的“应用”点，初步规划了这几个：

1. REPL：调用系统命令，模拟bash/cmd的基本操作（例如`ls`、`cd`、`mkdir`、`rm`等）。
1. GUI：通过调用系统库，打开一个窗口，并显示一点内容。
1. 文件I/O：调用C标准库，读写文件。
1. 图表：调用Python的画图库，画出一个柱状图。
1. 三角形：调用JS的Canvas库，画出一个三角形。

这5个认为，分别对应了Z的5个应用场景：解释器（REPL）、编译器、C、Python和JS。

我们现在手头只有几个工具：

- 整数
- 常量字符串
- 最基本的函数（还需要在本章实现）

这样水平的工具在Z语言之内暂时还做不了什么有用的事情，不过借助函数去调用外部的生态，正是Z语言特色的一个良好的展示。

本节，我们先探讨一下要做到上述的事情，我们需要哪些关于函数的概念。

## 函数的基本组成

函数有4个基本组成：

1. 输入的数据，即**参数**。
1. 输出的结果，即**返回值**。
1. 具体的操作，即**函数体**。
1. 函数的名称，即**函数名**。

在编程语言里，这4个要素的组合被称为**函数签名**（Function Signature），或**函数原型**（Function Prototype）。

例如，我们第一章就见过的Z语言唯一的`print`函数，它的签名应当是：

```z
fn print(s str)
```

这里，`fn`是表示函数的关键字，`print`是函数名，`s`是参数，`str`是`s`的类型。

这个函数没有指定返回值类型，所以默认是不返回。在C语言里，不返回用`void`表示。

这个函数和普通的函数不一样，因为它是编译器内置提供的，不需要程序员自己实现，因此它没有函数体。

那么有函数体的函数，应该怎么写呢？

例如，我们能想到的最简单的函数，应该是`add`，它的C语言形式如下：

```c
int add(int a, int b) {
    return a + b;
}
```

在Z语言里，应该是长这样：

```c
fn add(a int, b int) int {
    a + b
}
```

这里，`a`和`b`两个参数用`,`隔开，参数列表结束符为`)`，而`)`后面的`int`代表的是函数返回值的类型。

`{ a + b }`就是函数体，它的返回值是`a + b`。

上一章我们讲过，Z语言的表达式本身就是一个语句（和Python/JS类似），因此不需要单独写`return a + b`。

由于还没有深入介绍复杂语句，更复杂的函数体我们这里就不过多讨论了。
等下一章，有了`条件语句`、`循环语句`和`分支语句`的武器库之后，就可以探讨如何实现复杂的操作逻辑了。

参数和返回值的类型也是如此，由于我们现在只支持`int`型整数，以及不那么严谨的常量字符串，这里过多讨论也没有意义。这个内容需要等下一章探索了`变量`和`类型`的概念之后再细究。

这里只要知道它们表示`a`、`b`以及它们的和都是整数类型就可以了。

接下来，我们探讨如何去调用函数。

## 函数调用

第一章里，我们已经见到了Z语言函数调用的基本形式，和C语言没有什么区别：

```z
print("Hello")
```

基本的格式是这样的：

```
函数名(参数1, 参数2, ...)
```

如果有多个参数，就用`,`隔开。

如果函数没有参数，那么就用空的括号：

```z
run()
```

就这么多了。本章只实现最简单的形式。

Z语言还设计了更复杂的调用形式：

1. 类似Python的按参数名调用，例如`http.server(host="127.0.0.1", port=8080)`。
2. 对象参数解开，例如有一个对象`let config = {host: "127.0.0.1", port: 8080}`，那么上面的例子也可以写作`http.server(config)`，Z语言会自动解开对象，把`host`和`port`作为参数传入函数。
3. 匿名函数调用。类似于Kotlin，如果最后一个参数是一个匿名函数，那么可以把它写到括号外面，甚至在没有其他参数的情况下，省略掉括号。例如`thread.new(fn() { print("Hello") })`可以省略成`thread.new { print("Hello") }`。这种形式在函数式编程里可以方便地实现链式调用。

但这几种调用形式都会大大增加编译器的复杂度，且它们都是“锦上添花”的特性，并没有非实现不可的必要性，
所以本着“过早优化是万恶之源”的原则，这种“设计上的过早优化”，我们也先不做。

未来，当Z语言的基础特性完备之后，在实现高阶语言特性时，再进一步探讨这几种调用形式。

现在，只要实现了上面的基础调用形式，再配合上适当的“导入”语法。我们就已经可以尝试去调用外部生态提供的函数了。

我们先确定几个目标实例。

## 解释器和REPL

解释器和REPL种，我打算添加3个内置命令：`pwd`、`ls`和`cd`。

这三个命令的实习，只需要调用bash/cmd的命令即可。

先定义命令的格式：

1. `pwd`不需要任何参数，只需要输入`pwd`即可。也就是说，相当于`pwd()`。格式为`pwd`。
1. `ls`可以不输入参数（代表当前目录），也可以输入一个路径参数`path`。格式为`ls <path>`。
1. `cd`必须输入一个路径参数`path`。格式为`cd <path>`。

和`print`一样，我们把这三个命令定义成解释器的内置函数。也就是说，可以用类似`print("hello")`的方法来调用它们：

```z
>>> pwd()
>>> ls("..")
>>> cd("src")
```

但是这样输入显然不符合命令行的习惯，所以在REPL模式里，我设计了另一种特殊的调用语法：

- 对于任何命令`a`，如果不输入参数和括号就回车，那么相当于输入`a()`
- 如果在命令后输入空格，则每个空格里的内容对应于函数的一个参数，且此种参数必然是字符串类型。例如`ls .`相当于`ls(".")`，`cd src`相当于`cd("src")`。

这样，我们就可以把`cd src`这样的命令转换为对系统内置函数`cd "src"`的调用了。

有了这种语法，实际上`print`也可以这么写：

```z
>>> print Hello
Hello
```

当然，如果是"Hello, world"这样包含空格的字符串，还是得用`""`双引号括起来。

```z
>>> print "Hello, world"
```

这样，我们就可以在REPL里模拟命令行的基本操作了。

要实现上述的功能，需要两个步骤：

1. 在解释器里增加内置函数`pwd`、`ls`和`cd`。
1. 在REPL里增加对命令行调用的解析。

## 编译器

编译器的目标文件是汇编，我们可以通过汇编去执行系统调用，也可以直接调用C标准库做很多操作。

系统调用的重头戏是文件I/O和网络I/O，以及更高阶的线程、进程之类的并发操作。

现在我们只有最简单的函数，显然还不适合去玩高阶的操作，
因此本章的目标就是通过系统调用，实现简单的文件读写功能。

具体而言，就是要实现两个标准文件I/O函数：

```z
// 读取并打印文件内容
fn read_file(path str)

// 写入文件
fn write_file(path str, content str)
```

由于我们还没实现动态的字符串，`read_file`的暂时不返回任何内容，而是把读取的内容打印出来。

## 转译器

转译器分别翻译成C、Python和JS。

这三个目标语言，以及它们配套的生态，所擅长的优势并不一致。

因此我打算做一件比较有趣的事情：在每个生态里做不同的事情。

实际上，最初设计Z语言的这三个转译生态，就是为了能借助它们所各自擅长的领域：

- C：系统编程、网络服务、硬件相关开发、3D图形
- Python：科学计算、AI
- JS：前端开发、GUI开发、WEBGPU

因此，我并不追求“每段Z源码都能在C\Python\JS里运行”，而是反其道而行：

Z编译器会根据应用的场景，来选择适合的生态。

这也就是我所谓的**面向场景编程**模式的初衷。

考虑到`场景`是比`模块`还要高的抽象层次，我并不打算马上实现它，而是等第7章实现了模块化之后再来讨论。

本章我们手动来分辨场景即可。也就是说，假如一个函数是针对Python的，那么就不要在C或JS的示例里去调用它。

未来编译器实现完整的`面相场景编程`模式之后，就可以自动提示`场景错误`了。

本章依靠最简单的函数调用功能，我打算为这三个生态分别实现不同的用例：

- C：提供一个标准库函数`http_server`，可以在`Z`里调用它，启动一个简单的HTTP服务器。这个功能在Python里也很容易支持。
- Python：提供一个简单的标准库函数`draw_chart`，绘制一个柱状图。这个功能在JS里也不难添加支持（例如，调用echarts库）。
- JS：提供一个简单的标准库函数`draw_triangle`，绘制一个三角形。JS后端暂时采用`canvas`的API来实现，未来会增加对`WebGPU`的支持。

这三个库函数并不是通用的，例如我暂时不会去实现JS环境的`http_server`，因为Z的初版只设计浏览器前端的JS生态，而暂时不考虑Node.js。

## 生态配合

考虑到现在Z自身能力不成熟，大部分的工作都需要依靠外部生态来完成，
因此Z语言转译成C、Python和JS，需要这三个生态提供一定的辅助。

也就是说：

- C环境需要提供`http_server`的真正实现
- Python环境需要提供`draw_chart`的真正实现
- JS环境需要提供`draw_triangle`的真正实现

并且这三个环境都需要提供好对应的API，供`Z`语言生成的函数去调用。

这些辅助库，现在需要我们手动去用C、Python和JS来实现。

未来随着Z语言的能力越来越强，
很多功能可以用Z自己来实现，
并自动转译成对应的C/Python/JS源码。

那时候，我们对手动实现辅助库的依赖就会逐渐减少。


## 关于模块

上面三个库函数`http_server`、`draw_chart`和`draw_triangle`，所做的任务是不同范畴的。理论上应该把它们放到不同的模块里，例如：

- `http_server`应该放到`http`模块里
- `draw_chart`应该放到`chart`模块里
- `draw_triangle`应该放到`draw`模块里

但是，如果要实现模块，需要如下语言特性：

- 视野范围：模块内部的成员，默认应当只在模块内可见，除非显式地声明为`pub`（public）。在C++里，这个术语叫`namespace`。
- 导入语句：`use <module>`。
- 模块成员引用：`<module>.<member>`，例如`chart.draw_chart(5)`。

这几个特性在本书的这个阶段就实现，有点“过早优化”的感觉了。

因此，考虑到现在总过也没有几个标准库函数，我就把它们都放在一起了。
等未来实现了上述的特性之后，再挪到各自的模块里。

## 小结

本节讨论了函数的重要意义，以及为什么要这么早来做函数的功能的原因。

我又根据用途，针对不同生态设计了几个标准库函数，作为本章代码实现的驱动应用。

接下来几节，我就会分别在解释器（以及REPL）、编译器和三个转译器里分别实现上面介绍的那几个标准库函数。
