# 括号与负数

现在我们已经有了完整的四则运算，但还要补充括号和负数，才能算是一个“正确”的计算器。

为什么把括号和负数放在一起讲呢？

因为它们都是“一元运算符”，即只需要一个参数就能计算出结果的运算符。

括号（group）的语法规则是这样的：

```
group := '(' expr ')'
```

而负号（negative）的语法规则是这样的：

```
neg := '-' expr
```

其中，`expr`是通用的表达式，我们现在所处理过的`四则运算`(`binop`)、`函数调用`（`call`）和最基础的`整数`（`integer`），都属于表达式。

本节介绍的新的`括号`（`group`）和`负号`（`neg`），也都属于表达式。

括号和负号都是一元运算，即开始解析之后，只需要解析一个参数的运算。
唯一的区别是括号的结束条件是读取到`)`，而负号则不需要特殊的结束条件，直接往后解析一个表达式即可。

从这一点来说，其实`integer`也可以算是一元运算，它虽然没有自己算符，但是确实只有一个参数，并且它的判断方法是`token->kind == TK_INT`和那些需要判断一个算符的一元运算实际是一致的。所以我们可以把它归类到一元运算里，方便一起处理。

而`call`算是二元运算。因为它的左侧是函数名（`fname`），右侧是参数（`arg`）。这和`+`左侧是一个数，右侧也是一个数，从结构上来说是一样的。

总结一下，`expr`可以解析成为多种情况：

```
expr := integer | neg | group | call | binop
```

前三个操作是一元运算，后两个操作是二元运算。

那么在具体解析的过程中，如何区分应该采用哪个具体的规则呢？是`call`，还是`neg`？
幸好现在为止，我们的这几条规则都有明显的特征：

- `integer`：单个类型为`TK_INT`的词符。
- `neg`：以`-`开头的表达式。
- `group`：以`(`开头，以`)`结尾的表达式。
- `call`：以`name`开头，然后有`(`标志参数开始的表达式。
- `binop`：以`int`开头，然后有`+`、`-`、`*`、`/`标志的表达式。

有了`neg`和`group`之后，我发现`binop`也需要扩展了：

现在的`binop`只支持整数`int`的四则运算，
但是添加了负数`neg`和括号`group`之后，
所有出现`int`的地方，也应当可以替换成`neg`或`group`。

例如：

```
// 单纯的整数运算
1+2*3-4/2

// 支持负数和括号的四则运算
-1+-2*(4-2)
```

甚至可以再扩展一步，函数调用虽然现在只支持`print(...)`，它实际上是没有任何返回值的；
但未来我们会增加`pow(2 ,3)`这样的函数，它会返回一个整数，那么函数调用`call`也应当可以用于四则运算。

所以，实际上，`binop`的操作元应当是一个通用的`expr`，而不是单纯的`int`。

在具体解析的时候，我们应当这样处理：

1. 先尝试解析一个一元运算表达式（即neg/int/group/name等）。
2. 再看下一个词符，如果是二元操作符，那么就继续解析二元运算表达式（即binop/call）。
3. 递归调用上面的第2步，并根据操作符的优先级来判断是左结合、又结合还是退回上层。

为什么要先解析一个一元运算表达式呢？

因为复杂的表达式，不论是多少层次的嵌套，最左侧的表达式一定是一个一元操作：

- 如果是正常的整数或变量名开头，那么他们本身就是一元表达式。
- 如果是负号或括号开头，那么他们也是一元表达式。
- 如果是一个函数调用，那么它的左侧操作元（即`name`），也是一个一元表达式。
- 如果是四则运算，那么它的最左端的操作元，也是一个一元表达式。

所以对于任意表达式`expr`，都可以用上面的逻辑来处理。

接下来我们先实现`neg`和`group`，然后再来扩展`binop`。

## 负数

负数的实现非常简单，对现有的解析器影响也最小，所以我们先来实现它。

负数的语法规则如下：

```
neg := '-' integer
```

要区分`neg`和`integer`只需要判断第一个词符是`-`还是`TK_INT`即可。

```
switch (parser->cur->kind) {
case TK_MINUS:
    return neg(parser);
case TK_INT:
    return integer(parser);
}
```

其他所有的规则都没变。

我们可以把上面的`neg`和`integer`的判断合成一个`unary`解析函数：

```c
static Node *unary(Parser *parser) {
    switch (parser->cur->kind) {
    case TK_MINUS:
        return neg(parser);
    case TK_INT:
        return integer(parser);
    }
}
```

这样，解析器中出现`integer`的地方，直接替换成`unary`即可。
