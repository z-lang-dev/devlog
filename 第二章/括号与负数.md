# 括号与负数

现在我们已经有了完整的四则运算，但还要补充括号和负数，才能算是一个“正确”的计算器。

为什么把括号和负数放在一起讲呢？

因为它们都是“一元运算符”，即只需要一个参数就能计算出结果的运算符。

括号（group）的语法规则是这样的：

```
group := '(' expr ')'
```

而负号（negative）的语法规则是这样的：

```
neg := '-' expr
```

其中，`expr`是通用的表达式，我们现在所处理过的`四则运算`(`binop`)、`函数调用`（`call`）和最基础的`整数`（`integer`），都属于表达式。

本节介绍的新的`括号`（`group`）和`负号`（`neg`），也都属于表达式。

括号和负号都是一元运算，即开始解析之后，只需要解析一个参数的运算。
唯一的区别是括号的结束条件是读取到`)`，而负号则不需要特殊的结束条件，直接往后解析一个表达式即可。

从这一点来说，其实`integer`也可以算是一元运算，它虽然没有自己算符，但是确实只有一个参数，并且它的判断方法是`token->kind == TK_INT`和那些需要判断一个算符的一元运算实际是一致的。所以我们可以把它归类到一元运算里，方便一起处理。

而`call`算是二元运算。因为它的左侧是函数名（`fname`），右侧是参数（`arg`）。这和`+`左侧是一个数，右侧也是一个数，从结构上来说是一样的。

因此我们如果把一元运算和二元运算总结出来，分别取名叫`unaop`和`binop`，那么`expr`的语法规则就是：

```
expr := unaop | binop 
unaop := integer | neg | group
binaop := call | calc
```

注意，这里的`binop`比上一节的扩展了，包括了`call`的情况。而上一节`binop`处理四则运算的逻辑，我们改名成`calc`。



