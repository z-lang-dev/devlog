# 加减混合运算

本节实现加减法的混合运算。

只做个减法太简单了。
它和加法的实现除了符号不同，几乎完全一样。
单独作为一节并没有太大意义。

那为什么不把乘除法也放一起呢？
这是因为一旦引入乘除法，就必须牵涉到运算优先度的问题了，

例如，如果我们实现了`3*2-5`，但却没有检查优先度，
那么如果用户输入`3+2*5`，得到的会是`(3+2)*5`即`25`，而不是`13`。
这样就是错的。

但如果实现优先度，又太复杂了。
优先度的问题比本书至今的所有问题都复杂那么一点点，
它值得单独的一节来讨论。

所以我们先不管乘除法了，而是在本章实现任意加减法的混合运算。

## 减法

减法的情况类似，指令是`sub`。

`3-2`对应的汇编代码是：

```asm
mov rax, 3
sub rax, 2
ret
```

除此之外，减法的所有实现都和加法一致。

因为我们不单独给减法做用例了，而是直接做加减混合的用例。

减法的实现也和加法一样，所以就不赘述了。只要注意三点即可：

- 在`lexer.h`里添加减号的词符
- 在`parser.c`里判断`TK_SUB`，并组装成一个`ND_SUB`节点，它也用一个`BinOp`结构体来表示。
- 代码生成阶段的处理，并不需要单独做，因为我们现在需要一起处理，才能应付混合运算的情况。

## 混合运算

上一节中我们已经看到，要处理`1+2+3+4`这样的连加，现在的以`if-else`为骨架的解析器已经无能为力了，我们需要能循环判断的更复杂的解析器。

这个解析器还是从`TK_INT`开始，然后循环判断操作符，如果是`+`，就做一个`ND_ADD`节点，如果是`-`就做个`ND_SUB`节点，然后再继续判断下一个操作符。对于下一个操作符而言，现在做好的`ND_ADD`或`ND_SUB`节点就是它的左侧子节点。

例如，`1+2-3`，我们先遇到1，然后遇到`+`，然后遇到2，这样的话，就有了一个`ND_ADD`节点，它表达的是`(1+2)`的意思。接下里遇到`-`，再遇到`3`，那么得到的`ND_SUB`节点，它的左侧值应当是`ND_ADD`（即`(1+2)`，右侧值是`3`。

TODO：画图展示AST

所以我们解析的结果实际上是`(1+2)-3`。

用节点来表示是这个样子：

```
{
    kind: ND_SUB,
    as.bop: {
        op: OP_SUB,
        left: {
            kind: ND_ADD,
            as.bop: {
                op: OP_ADD,
                left: {
                    kind: ND_INT,
                    as.num: 1,
                },
                right: {
                    kind: ND_INT,
                    as.num: 2,
                },
            },
        },
        right: {
            kind: ND_INT,
            as.num: 3,
        },
    },
}
```

处理更长的输入，如`2+4+6+8+10`，它的结果实际上是`((((2+4)+6)+8)+10)`。

因此我们需要这样一个解析循环：

