# 最简单的编译器

上一节我们实现了最简单的解释器`interp`，本节我们实现`build`和`run`命令，把源码编译成可执行文件。


## 编译流程

编译器比解释器要复杂的多，在把源码解析成AST语法树之后，还要做几个步骤：

- 遍历AST，进行类型检查
- 将AST转换成中间代码（IR）
- 对IR进行多轮优化
- 将IR转换成目标代码
- 链接目标代码，生成可执行文件

有的编译器还不止一种IR，而是先转化为一种IR，进行某些检查和优化操作，再转化为另一种形式的IR，以便于进行更深入地优化，最终再转换成目标代码。

TODO: 画一个流程图

Z语言是一个循序渐进的语言，因此我们先忽略掉所有“锦上添花”的步骤，而只实现最简单的流程：

- 将AST转化为目标代码
- 调用外部工具进行链接并生成可执行文件

由于现在不需要考虑优化和跨平台，我们可以直接砍掉IR，未来再考虑加上。
我们选择一种比较常见的目标代码：GNU x86-64汇编，并借助gcc来进行链接和可执行文件的生成。

未来如果要扩充成严肃的编译器，可以有以下几个路径：

- 自研一套IR，自己写针对不同平台的汇编器和链接器。Go语言选择的是这个道路。
- 借助LLVM，这样就只需要把Z语言的AST翻译成LLVM IR，即可实现所有的优化操作和跨平台支持。Rust语言选择的是这个道路。
- 选择WASM作为目标代码，WASM有机会成为“真正的跨平台汇编”。现在所有的语言几乎都增加了wasm的选项。
- 不考虑代码生成，而以C作为目标代码，再借助gcc/clang等编译器实现所有平台的优化编译。V语言选择的是这个道路。

从经济性考虑的话，第二套方案显然更合理。第三套也可行，只是暂时还不太成熟。第四套本来就是Z语言三大转译目标之一，在后面会详细介绍。
但是从“学习”和“探索”的原则出发的话，显然第一套方案更有意义。因为我可以在自研IR和支持不同平台汇编的过程中学到更多东西。

所以我选择全部都要，或者至少保留所有方案的接口，这样以后大家有感兴趣的，可以来实现。

本章我们选择GNU x86-64汇编为目标代码，从zast直接生成它，再借用gcc命令来执行链接和生成可执行文件。
这样做有个缺点，就是只能Linux平台下跑。但作为第一次的尝试，并不是大问题。将来扩展编译器功能时，我会加上Windows的MASM64的支持；其他平台，例如移动端的ARM，新兴的RISC-V，国产的LoongArch，都可以加上。

#### 为什么不做类型检查？

最基本的类型检查可以在AST解析阶段就做好，而复杂一些的检查，往往是为了应付复杂的类型系统而产生的。现在的Z语言及其简单，可以说没有类型系统，所以这个问题暂时不用考虑。

我打算在添加了整数、浮点数和布尔类型之后，再做基本的类型检查和最简单的类型推导。

#### 为什么不做优化？

优化问题很重要，但是我认为它是纯纯的锦上添花的功能。过早地优化，会让编译流程变得非常复杂，并不适合Z语言循序渐进的“学习”和“探索”风格。
我打算把所有的优化工作都放在功能实现完成之后，即先完善整个语言的所有特性，再来考虑优化问题。

#### 为什么不做IR？

IR本身是为了跨平台和优化而生的。Z语言现在不需要考虑优化，平台也暂时只支持Linux和Windows。

另一方面，IR的设计也是个复杂的问题，我打算深入学习了LLVM IR、MIR、Go IR和WASM之后，再来考虑自研IR的问题。

所以，IR的问题也要放在语言特性完整之后，在添加LLVM或WASM的后端时再研究了。

#### 为什么不自己实现链接器？

链接器是一个有趣的问题，我以后会考虑学习并实现一套实验性质的链接器。
但链接器这个问题比较独立，和编译流程没有多少交集，且涉及非常多操作系统的细节，我把它的优先度放在了优化问题之后。

## GNU x86-64汇编