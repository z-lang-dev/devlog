# 最简单的转译器 - C语言版

前面我们已经实现好了基本的解释器和编译器，现在我们来实现一个转译器。

本章先回归老本行：C。

为什么先选C？因为Z语言本来就是用C实现的。

用C语言写一个Z->C的转译器，岂不是很有趣？
更进一步，如果Z语言足够成熟了，我就可以用Z来重写这个转译器。
那么情况就变成了：用C写的Z编译器编译一个Z写的Z->C转译器。
如果再进一步，再做一个C->Z的反向转译器，并把现有的C实现的Z编译器转成Z的实现呢？
那么我们就有了 Z->C->Z->C 了。

实际上，在现有的Z语言框架里，C转译器和编译器没有本质的区别：

转译器是Z->C，而编译器是Z->ASM，这是相同的过程。之后要运行的话，也都需要调用`clang`或`ml64`来生成可执行文件。

因此实现Z->C的转译器`z2c`，是最容易的。

而下一步我们要实现`z2python`的时候，在生成了`python`文件之后，
就需要研究怎么调用Python的虚拟机去执行它了。
那就是新的问题了。

JS也是类似的情况。

所以选择C作为第一个转译器，是最顺其自然的。


# 目标程序

对比一下Hello World的Z程序和C程序：

```z
print("Hello, world!")
```

```c
#include <stdio.h>

int main(void) {
    printf("Hello, world!\n");
    return 0;
}
```

和前面的编译器一样，我们只要把`"Hello, world!"`解析出来，然后替换到这个C文件里即可。

因此Z到zast的解析可以复用，我们只需要实现一个类似`codegen`的函数即可。
我们把它叫做`transpile`。

首先，在`main.c`里添加一个新的命令`trans`，和`build`、`interp`并列：





