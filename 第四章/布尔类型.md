# 布尔类型

第四章的主要目的是做出复杂的表达式和语句来。
其中最有代表性的就是条件语句`if-else`和循环语句`for`。

但是这两个语句都需要一个基础：比较运算。

不论是条件分支，还是循环判断，都需要进行比较运算，并得出不同的结果。

因此，我需要先单独花一节来实现比较运算。

而比较运算的结果是“真”（`true`）或“假”（`false`），
在计算机术语里，这两个值组合成布尔值（`boolean`），
它是独立于整数、浮点数之外的另一种基本数据类型。

所以，在实现比较运算之前，还要先实现布尔类型。

## 布尔值的实现

Z语言里，布尔类型的名称是`bool`，即`boolean`的简写。

布尔类型（`bool`）本身很容易实现，只需要实现`true`和`false`两个值就可以了。在计算机中，`0`代表`false`，非`0`代表`true`，因此它们的存储也很简单。

但是，新增一种数据类型，现在的Z语言来说，其实是一个比较大的冲击：
现在的Z编译器只支持整数这一种类型，如果要添加新的类型，就要把所有涉及到存值的地方从整数值扩展成支持多种类型的值。

也就是说，我们之前所有涉及到`value`的地方都是用`int`来存储，
而现在`value`不但可以是`int`，还可以是`bool`。甚至未来还可以是一个`str`、一个`array`、一个`dict`...

是不是看到了似曾相识的关联？

没错！我们可以用`tagged-union`来解决这个问题。

```c
// 存值的种类
typedef enum {
    VAL_INT, /**< 整数值 */
    VAL_BOOL /**< 布尔值 */
} ValueKind;

// 存值：即存量对应的值
typedef struct Value Value;
struct Value {
    ValueKind kind; /**< 存值的种类 */
    union {
        int num; /**< 整数值 */
        bool bul; /**< 布尔值 */
    } as;
};
```

这里由于`bool`是个关键字，没法用作C变量名，因此我就用读音类似的`bul`替代了。
其实整数叫做`num`也是相同的原因。

其实用下划线会更规整：

```c
union {
    int _int;
    bool _bool;
}
```

但我不太喜欢下划线，所以就没有选择这么做了。

我们先在解释器里试验一下，用`Value`替代之前单纯的`int`。

首先，是最常见的`eval`函数，它现在返回的值是`int`类型的，需要改为`Value`。

进过一番修改，`eval`对`Value`类提出了几个新需求：

- `Value*`之间应该能够进行四则运算。
- `Value*`应该要能取负号。
- 哈希表存取的内容要从`int`改为`Value`。
- `Value*`应该有打印函数

这样，在改写的过程中就形成了如下的`接口`：

```c
// value.h
Value *new_int(int num);
Value *new_bool(bool bul);

Value *neg_val(Value *val);
Value *add_val(Value *a, Value *b);
Value *mul_val(Value *a, Value *b);
Value *div_val(Value *a, Value *b);

void print_val(Value *val);
```

具体的实现都很简单，就不贴代码了。

再稍微修改一下`interp`和`repl`的逻辑，就能运行了。

并且，所有的用例也都能通过。

这样我就可以提交一个小版本了。

```bash
$ git commit -a -m "步骤29：解释器支持布尔类型"
$ git tag -a v0.0.29 -m "步骤29：解释器支持布尔类型"
$ git push
```
