# 定量

第一节我们实现了基本的定量，但是直到上一节做好了哈希表，才能在解释器里跑出来。

本节继续定量的工作，实现在编译器和转译器里对定量的初步支持。

## 编译器

编译器里，定量的存储和解释器完全不同。

在解释器里，我们把定量存放在一个哈希表里，这样可以方便地查找和修改。
但在编译器里，所有的东西最终都要变成汇编，所以定量也要存储到汇编里去。

在前两章我们已经知道，汇编里把常量存放在`.data`字段里，
而`.data`字段是全局的，又是只读的，
适合用来存放常量，会在整个程序运行期间一直存在。
这样的特性，让`.data`字段只适合存放常量和全局的定量。

局部的定量和变量，生命周期都比较短，汇编中一般把他们存放在运行栈中。

在上一章函数中，我们也提到过，如果参数超过4个（Linux下是6个），多出来的参数就是用栈来传递的。
换句话说，函数参数和局部的存量，本质上是非常相似的。

对于函数内部的代码来说，存在栈上的参数和存在栈上的局部存量，并没有什么区别。

也就是说，一旦实现了局部存量，那么要扩展函数，让它支持更多的参数，也不是很麻烦的事情。

我们先来了解一下运行栈是怎么存放数据的。

## 运行栈（The Stack）

我们经常听说一个变量存在“栈上”或者“堆上”，但是我一直没搞清楚它们到底在哪里。

只有一个大概的印象：栈是一个很近的地方，所以栈上的变量访问很快；而堆似乎是个很远的地方，只能通过指针跳转去访问，还要申请空间、释放空间，所以比较慢。

还常听到这样一种说法：“能放在栈上，就不要放在堆上”。

其实画个图，就能看得很清楚了：

![memory_layout](./memory_layout.png)

注意：这个图中，为了方便理解栈，内存的地址是从上往下增长的。也就是说，加入从零开始的话，那么最上面是0x00000000，最下面是0xFFFFFFFF。

整个图是一段运行的程序（即一个进程）的内存布局，从上到下依次是：

- .text/.code段：即程序的代码本身。这段内存是只读的。
- .data数据段：存放全局变量和常量。这段内存分成两个部分，一部分是只读的，用来存放全局变量。
- .bss段：存放未初始化的全局变量。这段内存是可读写的。
- heap：堆。这就是我们常说的堆。它的大小是不固定的，可以向下动态增长。
- stack：栈。这就是我们常说的栈。它的大小也不是固定，它从程序的最后一段内存开始，向上动态增长。
- 命令行参数区：这里存放了命令行的参数。

值得注意的是，程序分配了一大块内存，而堆和栈之间的内存是空闲的。堆和栈放在两头，向中间增长，这样可以确保它们都有足够的空间。

但也有一种极端的情况，就是栈或者堆一直增长，直到两者撞到了一起，这时候就内存爆炸了。

我们常说的“stack overflow”就是这个意思，它往往是由于递归调用函数，但是没有写好停止条件，就好不停地调用新的函数，增加栈空间。

这个图中，如果忽略掉最下面的命令行参数区的话，基本可以把栈看做是在整个程序的最底端开始，向上增长的一段。

那么如何理解栈的生长（以及销毁）呢？

我们知道，每个函数的调用，都需要在栈上存储一些内容，它们占据一小块内存。这个函数运行结束之后，就会清空这段内存。

如果把每个函数看做一个盘子的话，那么栈就是一叠从下往上垒的盘子。
每调用一个函数，就往上再叠一个盘子，栈就增长了；
函数结束返回时，盘子就被拿走了，栈就缩短了。
如果函数内部又调用了其他的函数，那就再往上叠盘子。

举个例子，比如这个程序：

```c
#include <stdio.h>

int add(int a, int b) {
    return a + b;
}

int main() {
    int c = add(1, 2); // 第一个函数调用
    printf("%d\n", c); // 第二个函数调用
    return 0;
}
```

最底下的一个盘子就是整个进程的入口，但它往往并不是我们写的`main`函数，而是系统自己启动的一个函数。
例如在Linux中，启动的函数叫`_start`，它是最底下的盘子。
它会调用`main`函数，所以`main`是第二个盘子。

`main`函数开始时，整个栈里只有两个盘子。
当`main`调用第一个函数，即`add`的时候，就叠了三个盘子了。

假如我们用调试器打断点，停在`add`函数里的`return a+b`这一行，就会发现，此时栈里有三个盘子，从下到上分别是`_start`、`main`、`add`。这也是栈最高的时候。

`add`返回之后，它的盘子会被拿走，栈里又只有两个盘子了。再调用`printf`，又叠了一个盘子。

整个程序的运行过程中，栈里最多叠了三层：`_start`、`main`、`add`，或者`_start`、`main`、`printf`。

那么参数和局部变量在哪里呢？就在这些盘子里。

放大看看，每一个函数占用的空间实际上可以看做一个方块。
里面一条条的，就是这个函数运行时用到的数据。

这个方块，也可以叫做方框（frame），就是我们常说的“栈帧”（stack frame）。“帧”其实就是“框”的意思。

那么栈帧里的数据又是怎么排布的呢？都有哪些数据？函数在调用前后它是怎么变化的呢？
局部变量又是怎么存放和使用的呢？

我们来细细观察放大的图，看看栈帧的内部。

## 栈帧

栈帧的内部结构如下图：

![stack_frame](./stack_frame.png)

图中有几个关键的部分需要说明：

- 栈指针（`rsp`）：指向栈顶的指针。
- 临时值（`temporary values`）：函数内部临时使用的值。
- 参数（`arguments`）：调用函数时传入的参数。
- 局部变量（`local variables`）：函数内部定义的变量。
- 上一个RBP（`previous RBP`）：调用函数的RBP的值。
- 返回地址（`return address`）：调用函数的下一条指令的地址。
- 基址指针（`rbp`）：指向栈帧的开头的指针。

下面分别说明一下。

### 基址指针`rbp`

整个帧的开头，叫做“基址指针”（`rbp`）

### 栈指针`rsp`

首先，整个栈的顶端，叫做“栈顶”，寄存器`rsp`（`stack pointer`）总是指向它。
我们所说的栈“增长”或着“缩减”，就是靠对这个寄存器进行加减法来实现的。

注意，这个栈顶虽然是栈的顶部，但是它指向的地址是整个帧的最低地址，这是因为整个栈是从程序内存的末尾（即最高地址）向程序开头部分反向增长的。

所以，如果我们要给栈增加8个字节的空间，用的是`sub rsp, 8`，而不是`add rsp, 8`。

### 返回地址

栈帧的最后一个成员是“返回地址”（return address）。
注意，它指向的不是栈上的地址，而是调用它的函数的指令地址。
具体的说，是调用它的函数的下一条指令的地址。

回顾一下上面的内存布局图，指令地址是存放在图中最顶上的`.text`或者`.code`区域的，在程序内存的开头，
和底部的栈所在的地方八竿子都打不着。

那么这个`返回地址`是怎么来的呢？没错，是`call`指令干的。`call`指令做的事情，就是先把当前`rip`的下一个地址（也就是如果调用完函数，下一个要执行的指令地址）`push`到栈上，然后再把`rip`改成目标函数的指令地址，开始执行的。

当调用的函数返回的时候，`ret`指令执行，会把这个地址`pop`出来，并传给`rip`指令寄存器，这样CPU下一步就能找到正确的地方执行了。

也就是说，`call`相当于执行了：

```asm
push rip
mov rip, [function_address]
```

而`ret`相当于：

```asm
pop rip
```

而`rip`寄存器，也就是`instruction pointer`，存放的是计算机下一个执行的指令地址。所有的跳转指令都是通过曹总这个寄存器来实现的。

栈帧的第二个成员是“上一个RBP”（previous RBP）。