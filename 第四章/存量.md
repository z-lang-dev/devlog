# 存量

“存量”是我发明的名字。

这是因为我们常说的“变量”概念已经非常混杂了。
Z语言作为现代语言，虽然是个玩具版的，但也要紧跟时事不是么，必须引入“不可变变量”。
况且，Z语言要兼容C、Python和JS三个生态，又进一步增加了复杂性。

至此，我发现Z需要支持4种不同的“量”：

- 常量：`const`，全局存户，不可改变，类似C语言的`const`。
- 定量：`let`，局部存储，不可改变，类似于Kotlin的`val`。
- 变量：`mut`，局部存储，值可改变，类型固定，类似于Kotlin的`var`。
- 幻量：`var`，局部存储，值可改变，类型也可以改变，类似于JS的`var`。

当然，其实还有要其他更微妙的量：

- 元量：只存在于代码中，不存在于运行时的常量。类似于C语言的`#define`宏，编译期直接替换成成字面量了。
- 易量：volatile，易燃易爆炸的量。但我现在都没法简单解释清楚它是啥。
- 值量：value，即上面所有的“量”所实际存储的数值。

这些概念，平时在使用时术语很混杂。

比如之前大家都说“变量”，后来有了`immutable`的时候，就分成了“可变变量”和“不可变变量”。
但是什么叫“不可变”的“变”量呢？这个词本身意思就很矛盾，又那么长，干嘛不直接取个反义词呢？

所谓“不可变”，就是“恒定”。所以可以取名“恒量”或“常量”。

但是自从我知道“道可道，非常道；名可名，非常名”这句话的原本是“道可道，非恒道；名可名，非恒名”之后，我就不敢用“恒”字了。这“恒”比“常”还猛。要不是汉文帝，`const`就应该是“恒量”了。

所以只能取比“恒”、“常”更弱一些的“定”字，倒也确实复合这几个字的本意。

只是“定量”这个词已经在其他语境里有所代表了，比如“定量分析”。我也一直有所疑虑。
犹豫来犹豫去，就到了写书的时候了，这时候想：“再不定就晚了！”，“那就定吧！”，“定啥？”，“定‘定’！”。
就这么定了“定量”。

还好我只在Z语言这个小语境里用它，大家不必担心混淆。

说完了常量和定量，再说“变幻”这两兄弟。

变量没什么好说的，大部分语言都认它。但是问题在于动态类型语言（Python/JS）里，它们也叫`var`。
这就很尴尬了，傻傻分不清。

实际上它们真正的异同，就在于上面讲的：“值可以改变，类型也可以改变”。只有值能变的，是静态变量；类型也能变的，是动态变量。

那么为什么不简单地叫“动量”呢？其实我觉得也可以。虽然“动量”是物理常见名词，但“定量”我不也用了嘛。
但是我仔细体味了数日，感觉还是用“幻量”吧。最重要的原因，是“幻”字更贴近这种量的本质。它可以随时幻化成另一个“种族”的量，是不是很有九尾狐狸的既视感？相比起来，“动”字更多的是与“静”相对应，体会不出比“变”更能变化的感觉来。所以我觉得“幻”字更合适；况且它还没有和物理的“动量”冲突的问题。

这样，就定下了“常定变幻”四种量，那用什么名字来总称它们呢？

之前大家习惯于用“变量”来代称它们，这有点以偏概全了，容易引起误会，所以不得不经常加上“不可变变量”、“可变变量”、“动态变量”、“静态变量”之类的繁琐称呼。

而只用一个字“量”来表示它们，有一点太宽泛了；况且现代中文白话文已经变成了“双字词”为主体的语言了，句子里蹦出一个单字词，会比较别扭。

所以我给他们找了个共性：它们都是把数值存储到计算机的某个位置的量，所以就统一叫“存量”吧。

这个词我觉得挺好的，因为能“存”就有地址，就能很容易联想到“指针”了。

名字定了，那么它们对应的关键字呢？

常量：`const`没什么争议，大家都这么用的。

定量：Swift和Rust用`let`，Kotlin用`val`，D语言用`immutable`。`val`容易和`var`混淆；`immutable`太长，`imm`又有点莫名其妙，所以似乎只能选择`let`了，我是这么理解的：`let`是`let it be`的缩写，很有上帝造物的感觉。所以挺喜欢用。

变量：`var`是`variable`，而`mut`是`mutable`，类似的词还有`changeable`、`transferable`，但它们的缩写`cha`、`tra`都缺乏区分度。用`var`本来是最保险的，但是太容易和JS里的`var`混淆了，所以我还是及选择了`mut`。本来这个词也不常用，但幸好Rust火了，它用的`let mut`把`mut`也带成了常用词。

总而言之：Z语言设计了四种存量，分别是常量（`const`）、定量（`let`）、变量（`mut`）和幻量（`var`）。

## 定量

要我一下子实现4种存量，显然不现实。所以我先选择里头最容易实现的一种。

我选择了定量`let`。

常量感觉用途没有定量那么广；变量比定量多一个赋值操作；幻量在编译器和z2c转译器里都很难实现。
所以我打算先实现定量`let`，然后等做了复合语句之后，再回过头来实现变量`mut`和常量`const`。
至于幻量`var`，要放到后面几章去了。

另一个原因，是现代编程语言都倡导使用定量而不是变量，因为定量更安全，更容易推理，更适合函数式编程，也更容易做并发。
这些优势在现在简单的Z语言框架下还体现不出来，但按照行业智慧来做，总是不容易错的。

定量的本质是把一个“名称”（`name`）和一个“数值”（`value`）绑定起来，以便在后面能用这个名称去代具体的数值。

这里的“数值”包括我们已经实现的“整数”和“字符串”，以及未来要实现的“复合数据”类型，如“数组”、“字典”或“对象”等。任何能用来计算的“数据”（`data`），都可以看做是一个“数值”（`value`）。

存量，尤其是定量，它的概念应该是来源于数学函数。数值千变万化，难以捉摸，但是用一个符号把它们的规律抽象出来，代替具体的数值，从运算走向推理，从数据得到公式，从而得到定律，才让人类走向了智慧的殿堂。

$F = \frac {Gm_1m_2}{r²}$

看这美妙的公式，`F`、`m1`、`m2`、`r`都是定量，`G`是一个常量。它们都是数值的抽象，可以给定任何数值，但是它们的关系是恒定的，这就是数学的力量。

数学公式，也就是`函数`，有这样美妙的特性：对于同样的输入，它永远会得到同样的输出。在程序里，在函数的实现之中，定量对于这个特性的保持是非常重要的。我们把这种函数称为“纯函数”（`pure function`）。


现在我们来实现定量`let`。它的语法形式是：

```z
let <name> = <value>
```

如果把`=`读作`be`，那么这句话就相当于`let <name> be <value>`。联想到`Let there be light`，是不是让定量有了一点逼格？

我们的编译器要做的事情，就是读取这个名字和数值的匹配关系，并在未来任何用到定量名字的地方，都按照需求替换成它所代表的数值。