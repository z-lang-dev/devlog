# 条件语句

现在我们逐渐进入编译器开发的甜蜜期了。
整套框架已经比较熟练，而新功能的添加层出不穷。
仿佛每一天，都有很大的进展，成就感满满。

接下来的几节，条件语句、循环语句、自定义函数，
都会让Z语言的能力获得长足的提升。
我估计，接下来三节应该是成就感最强的三节了。
之后要添加的内容，可就没那么容易实现了。

先来对付最简单，但又是最重要的：“条件语句”。

## 条件语句的语法

条件语句的语法如下：

```z
if <条件> {
   //if分支
} else {
   // else分支
}
```

这里的条件是是一个最终得到布尔值的表达式。

Z语言的`if`语句和Go语言类似，条件不需要用括号，但分支的花括号反而是必须的。
这样的设计，是为了避免类似于Apple著名的[`goto fail`](https://en.wikipedia.org/wiki/Unreachable_code#goto_fail_bug)漏洞。

`goto fail`的相信信息可以参考[这篇文章](https://www.synopsys.com/blogs/software-security/understanding-apple-goto-fail-vulnerability-2.html)。

下面是`goto fail`的简化示例：

```c
if (condition1)
    goto fail;

if (condition2)
    goto fail;

if (condition3);
    goto fail;
    goto fail;

// success
do_something_succesful()...
```

这段代码前面做了一些列安全检查，如果没成功，就跳转到`fail`标签。
直到所有的检查都通过，才会执行`success`标签后面的代码。

结果有一次提交代码时，程序员多拷贝了一句`goto fail;`，在这里：

```c
// ...
if (condition3)
    goto fail;
    goto fail;

// success
```

这里的第一句`goto fail`只有满足`condition3`时才会执行，
但第二句`goto fail`并不属于`if`的分支！
它实际上是：

```c
// ...
if (condition3) {
    goto fail;
}

goto fail;

// succ
```

第二句`goto fail`实际上是一个单独的语句。它必然会被执行！
也就是说，后面的`success`语句永远没法执行了。

凑巧的是这整个函数恰好是用来验证用户安全的，结果提前返回了之后，
后面应该继续执行的安全检查没有做，最后导致了大规模的漏洞。

当然，这个漏洞的第一大原因是程序员错误地多复制了一行，
第二大原因可能是不该用`goto`，
但无论如何，如果`if`语句和之后的语句之间有“无法歧义”的分隔，这个错误就不会发生了。

例如，如果规定`if`语句必须用花括号括起来，那么这段代码会变成：

```c
if (condition3) {
    goto fail;
    goto fail;
}

// succ;
```

这时第二句`goto fail`就变成死代码了，永远不会执行。而且聪明的编译器还会提示错误。
那么这个漏洞就不会发生。

所以，Z语言规定花括号是必须的。

但是也许有人会问，如果我想要类似于`cond ? a : b`这样的表达式怎么办？
有点语言可以用`if-else`表达式来写：

```c
let x = if cond a else b
```

Z语言也可以实现，不过必须有花括号：

```z
let x = if cond { a } else { b }
```

我觉得不是问题。另外，还可以搞个语法糖:

```v
let x = a if cond else b
```

这种特殊的`前缀if`表达式，不能接语句，所以也不会出现问题。
这种语法我也忘了是在哪个语言里看到的了。

最终我还是选了类似于Go的道路，用单个形式处理所有情况：

```z
if cond {
    a
} else {
    b
}
```

两个分支是正常的语句块（`block`），可以写多条语句，
整个分支块也是一个表达式，它的最终值就是最后条语句的表达式值。

而整个`if`语句的最终值，就是根据条件选择的那个分支语句块的值。

所以，我们可以写：

```z
let msg = if cond {
    let d = fetch_from_db()
    let r = compute(d)
    log(r)
    r
} else {
    let f = load_from_file()
    log(f)
    f
}
```

这里`msg`最终得到的值，如果`cond`为`true`时，则是`r`；否则是`f`。

本节我们先实现最简单的跳转逻辑，即单独的`if`；
然后再实现`if`+`else`；
最后再实现语句块。


## 单独if语句

单独`if`语句的形式如下：

```z
if cond {
    do_some_thing()
}

do_another_thing()
```

和`else`不同的是，不论条件如何，`do_another_thing()`都会执行。
也就是说，`if`语句里的内容只是正常故事流程中途的一点小波澜而已。

我们先来实现`if`语句的AST节点，即在`zast.h`中添加一个`ND_IF`类型。

```c
```

那应该怎么实现这个跳转的逻辑呢？

我们知道，程序在计算机里是一条一条指令执行的。
代码存放在内存中的`.code`区域，每一条对应于我们生成的一条汇编指令。
CPU执行指令的方法是读取专门的指令地址寄存器`RIP`，
然后根据`RIP`的值从`.code`内存区域取出一行代码，然后执行。

因此，想要跳转到某一行代码，
我们只需要知道它在`.code`里的地址，然后把这个地址写入`RIP`就可以了。

由于这种操作太过常见，X64指令集亲切地为我们提供了一系列方便的`jmp`指令，
就不用我们亲自操纵`RIP`了。

更有甚者，他们也知道我们很难搞清楚指令真正的地址，
还在汇编里提供了方便的标签（label）功能。
想要跳到哪一行代码，只要在那一行代码的汇编里加一个标签就能直接跳过去了。

例如上面的代码，假设是这个样子：


```z
mut a = 1
if a > 0 {
    // do something
    a = 2
}

// do another thing
a = 5
```

我们先忽略掉`if`，那么这段代码的汇编是这样的：

```asm
    mov a$[rbp], 1 ; mut a = 1
    mov a$[rbp], 2 ; a = 2
    mov a$[rbp], 5 ; a = 5
```

如果我们想跳到`a = 5`这一行，只要在它前面加一个标签就可以了：

```asm
    mov a$[rbp], 1 ; mut a = 1
    jmp .L1         ; jump to .L1
    mov a$[rbp], 2 ; a = 2
.L1:mov a$[rbp], 5 ; a = 5
```

这样，当执行到`jmp .L1`时，CPU会直接跳到`.L1`标签所在的那一行。
那么`jmp`紧挨着的`a = 2`那一句就会被跳过去。

所以，所谓if语句，就是在`if`的位置判断一下条件，然后根据条件跳转到不同的标签即可。





