# 存量

“存量”是我发明的名字。

这是因为我们常说的“变量”概念已经非常混杂了。

Z语言作为现代语言，虽然是个玩具版的，但也要紧跟时事不是么，必须引入“不可变变量”。
况且，Z语言要兼容C、Python和JS三个生态，又进一步增加了复杂性。

至此，我发现Z需要支持4种不同的“量”：

- 常量：`const`，全局存户，不可改变，类似C语言的`const`。
- 定量：`let`，局部存储，不可改变，类似于Kotlin的`val`。
- 变量：`mut`，局部存储，值可改变，类型固定，类似于Kotlin的`var`。
- 幻量：`var`，局部存储，值可改变，类型也可以改变，类似于JS的`var`。

当然，其实还有要其他更微妙的量：

- 元量：只存在于代码中，不存在于运行时的常量。类似于C语言的`#define`宏，编译期直接替换成成字面量了。
- 易量：volatile，易燃易爆炸的量。但我现在都没法简单解释清楚它是啥。
- 值量：value，即上面所有的“量”所实际存储的数值。

这些概念，平时在使用时术语很混杂。

比如之前大家都说“变量”，后来有了`immutable`的时候，就分成了“可变变量”和“不可变变量”。
但是什么叫“不可变”的“变”量呢？这个词本身意思就很矛盾，又那么长，干嘛不直接取个反义词呢？

所谓“不可变”，就是“恒定”。所以可以取名“恒量”或“常量”。

但是自从我知道“道可道，非常道；名可名，非常名”这句话的原本是“道可道，非恒道；名可名，非恒名”之后，我就不敢用“恒”字了。这“恒”比“常”还猛。要不是汉文帝，`const`就应该是“恒量”了。

所以只能取比“恒”、“常”更弱一些的“定”字，倒也确实复合这几个字的本意。

只是“定量”这个词已经在其他语境里有所代表了，比如“定量分析”。我也一直有所疑虑。
犹豫来犹豫去，就到了写书的时候了，这时候想：“再不定就晚了！”，“那就定吧！”，“定啥？”，“定‘定’！”。
就这么定了“定量”。

还好我只在Z语言这个小语境里用它，大家不必担心混淆。

说完了常量和定量，再说“变幻”这两兄弟。

变量没什么好说的，大部分语言都认它。但是问题在于动态类型语言（Python/JS）里，它们也叫`var`。
这就很尴尬了，傻傻分不清。

实际上它们真正的异同，就在于上面讲的：“值可以改变，类型也可以改变”。只有值能变的，是静态变量；类型也能变的，是动态变量。

那么为什么不简单地叫“动量”呢？其实我觉得也可以。虽然“动量”是物理常见名词，但“定量”我不也用了嘛。
但是我仔细体味了数日，感觉还是用“幻量”吧。最重要的原因，是“幻”字更贴近这种量的本质。它可以随时幻化成另一个“种族”的量，是不是很有九尾狐狸的既视感？相比起来，“动”字更多的是与“静”相对应，体会不出比“变”更能变化的感觉来。所以我觉得“幻”字更合适；况且它还没有和物理的“动量”冲突的问题。

这样，就定下了“常定变幻”四种量，那用什么名字来总称它们呢？

之前大家习惯于用“变量”来代称它们，这有点以偏概全了，容易引起误会，所以不得不经常加上“不可变变量”、“可变变量”、“动态变量”、“静态变量”之类的繁琐称呼。

而只用一个字“量”来表示它们，有一点太宽泛了；况且现代中文白话文已经变成了“双字词”为主体的语言了，句子里蹦出一个单字词，会比较别扭。

所以我给他们找了个共性：它们都是把数值存储到计算机的某个位置的量，所以就统一叫“存量”吧。

这个词我觉得挺好的，因为能“存”就有地址，就能很容易联想到“指针”了。

名字定了，那么它们对应的关键字呢？

常量：`const`没什么争议，大家都这么用的。

定量：Swift和Rust用`let`，Kotlin用`val`，D语言用`immutable`。`val`容易和`var`混淆；`immutable`太长，`imm`又有点莫名其妙，所以似乎只能选择`let`了，我是这么理解的：`let`是`let it be`的缩写，很有上帝造物的感觉。所以挺喜欢用。

变量：`var`是`variable`，而`mut`是`mutable`，类似的词还有`changeable`、`transferable`，但它们的缩写`cha`、`tra`都缺乏区分度。用`var`本来是最保险的，但是太容易和JS里的`var`混淆了，所以我还是及选择了`mut`。本来这个词也不常用，但幸好Rust火了，它用的`let mut`把`mut`也带成了常用词。

总而言之：Z语言设计了四种存量，分别是常量（`const`）、定量（`let`）、变量（`mut`）和幻量（`var`）。

## 定量

要我一下子实现4种存量，显然不现实。所以我先选择里头最容易实现的一种。

我选择了定量`let`。

常量感觉用途没有定量那么广；变量比定量多一个赋值操作；幻量在编译器和z2c转译器里都很难实现。
所以我打算先实现定量`let`，然后等做了复合语句之后，再回过头来实现变量`mut`和常量`const`。
至于幻量`var`，要放到后面几章去了。

另一个原因，是现代编程语言都倡导使用定量而不是变量，因为定量更安全，更容易推理，更适合函数式编程，也更容易做并发。
这些优势在现在简单的Z语言框架下还体现不出来，但按照行业智慧来做，总是不容易错的。

定量的本质是把一个“名称”（`name`）和一个“数值”（`value`）绑定起来，以便在后面能用这个名称去代具体的数值。

这里的“数值”包括我们已经实现的“整数”和“字符串”，以及未来要实现的“复合数据”类型，如“数组”、“字典”或“对象”等。任何能用来计算的“数据”（`data`），都可以看做是一个“数值”（`value`）。

存量，尤其是定量，它的概念应该是来源于数学函数。数值千变万化，难以捉摸，但是用一个符号把它们的规律抽象出来，代替具体的数值，从运算走向推理，从数据得到公式，从而得到定律，才让人类走向了智慧的殿堂。

$F = \frac {Gm_1m_2}{r²}$

看这美妙的公式，`F`、`m1`、`m2`、`r`都是定量，`G`是一个常量。它们都是数值的抽象，可以给定任何数值，但是它们的关系是恒定的，这就是数学的力量。

数学公式，也就是`函数`，有这样美妙的特性：对于同样的输入，它永远会得到同样的输出。在程序里，在函数的实现之中，定量对于这个特性的保持是非常重要的。我们把这种函数称为“纯函数”（`pure function`）。


现在我们来实现定量`let`。它的语法形式是：

```z
let <name> = <value>
```

如果把`=`读作`be`，那么这句话就相当于`let <name> be <value>`。联想到`Let there be light`，是不是让定量有了一点逼格？

我们的编译器要做的事情，就是读取这个名字和数值的匹配关系，并在未来任何用到定量名字的地方，都按照需求替换成它所代表的数值。

## 前端支持

要支持这个功能，首先需要增加`let`和`=`对应的词符。

```c
// lexer.h
typedef enum {
    // ...
  TK_LET, // let
  TK_ASN, // =
  ...
} TokenKind;
```

在`lexer.c`里，`=`解析和其他单字符操作符一样简单：

```c
// next_token()
    case '=':
        return new_token(lexer, TK_ASN);
    // ...
```

而`let`是一个关键字，因此只要在`keywords`数组里添加一条就搞定了：

```c
static Keyword keywords[] = {
    {"use", TK_USE},
    {"let", TK_LET},
};
```

这样就完成了词符的支持。
接下来修改AST，增加`ND_LET`节点。
`ND_LET`有两个子节点，分别是代表存量的`ND_NAME`和代表`value`的一个表达式节点。

这里的`ND_NAME`其实就是之前函数里的`ND_FNAME`。

当时我设计的时候把函数名和存量名分开，分别叫`ND_FNAME`和`ND_SNAME`，
是因为考虑到函数名和存量名的用途不同。
但是现在再仔细考虑一番后发现，应该把它们统一起来。

在Z语言里，定义一个函数，应该和定义一个存量差不多，只不过存量的值是一个表达式，而函数的值是一个函数指针。
既然未来我们想要把函数做成语言的一等公民，那么应该能和存量进行互换，甚至函数定义本身也是一个表达式，也可以赋值给存量。
按照这个思路来设计的话，那么应该把存量名称和函数名称统一处理。

因此本节我们需要先把以往`parser`里的`ND_FNAME`都改成`ND_NAME`，并且也用它来处理存量名称。

右侧的`value`，并不一定只是基本数据，也可以是一个复杂表达式，比如：

```swift
// 四则运算
let sum = 1 + 2 + 3

// 函数调用
let sum = add(5, 2)

// 定量参与的运算
let a = 10
let b = 25
let c = a * b
```

所以我们的`ND_LET`节点应该是如下形式：

```c
struct Asn {
    Node *name; // ND_NAME
    Node *value; // EXPR
};

struct Node {
    NodeKind kind;
    void* meta;
    union {
        // ...
        Asn asn;
    } as;
};
```

也就是说，对于一个`ND_LET`的节点，访问它的两个成员的方法是：

```c
// 解析出一个`ND_LET`节点
Node *node = let(parser);
assert(node->kind == ND_LET);

// 获取定量名称
Node *name = node->as.asn.name;
assert(name->kind == ND_NAME);
char *name = name->as.str;

// 获取值节点
Node *value = node->as.asn.value;
// value值可以是任何表达式
switch (value->kind) {
case ND_NUM:
    break;
case ND_STR:
    break;
case ND_CALL:
    break;
case ND_BINOP:
    break;
// ....
}
```

因为有`let`关键字开头，
`ND_LET`节点也可以看做是个一元表达式，
只不过它后面跟的是三个固定节点：`name`、`=`和`value`。

```c
let <name> = <value>
```

当然，未来可能支持“先声明，再赋值”的语法，像这样：

```c
let a
// ....
a = 5
```

但考虑到`let`的本质是不可变的，那么就必须确保赋值操作只发生一次，否则就不是定量了。
另外在`a`的声明和赋值之间，也可能会被其他表达式用到，这也应当是不允许的。

这两个因素导致编译器需要做很多静态分析，才能确保不出错。
也就是说，这种特性增加了很多不必要的复杂度和风险，我觉得不值得。

因此我暂时不打算支持这种语法。

要是变量`mut`倒是可以这么做，因为它是可以改变的，
所以可以声明时就给个默认值，后面的赋值其实是修改。
这样中途用它也没问题，后面修改多少次也没问题。

所以，我们的`ND_LET`节点，就固定这么解析：

```c
static Node *let(Parser *parser) {
    // 跳过'let'
    advance(parser);
    Node *expr = new_node(ND_LET);

    // 解析存量名称
    Node *name = new_node(ND_NAME);
    name->as.str = get_text(parser);
    expr->as.asn.name = name;
    advance(parser);

    // 解析'='
    expect(parser, TK_ASN);

    // 解析数值表达式
    expr->as.asn.value = expression(parser);
    return expr;
}
```

这段解析的结构很清晰，唯一需要注意的是`name`并不是一个字符串，而是一个`ND_NAME`节点，它的`as.str`才是字符串。

为什么要搞这么麻烦？因为未来我们可能要对这个节点添加更多的元信息，所以至少要保留一个`meta`的指针，而不是单纯的字符串。

把`let()`解析函数放到`unary`里，就可以正常触发了：

```c
static Node *unary(Parser *parser) {
  switch (parser->cur->kind) {
    case TK_LET:
        return let(parser);
    case TK_USE:
        return use(parser);
    // ...
  }
}
```

再配合上打印节点的功能，我们就可以通过`trace_node()`看到解析出的节点了。

## 解释器

解释器里需要添加对`ND_LET`的支持。

由于现在我们只进行了`let`声明，还没实现怎么去使用这个定量，
所以先做最简单的处理，即遇到`let`语句时，直接打印出它的名字和对应的值即可：

```c
int eval(Node *expr) {
    switch (expr->kind) {
    // ...
    case ND_LET: {
        int val = eval(expr->as.asn.value);
        printf("%s: %d\n", expr->as.asn.name->as.str,  val);
        return val;
    }
    // ...
    }
```

`let`表达式的返回值就是它的`value`值。

这样，我们就可以进行初步的测试了：

```bash
$ xmake run z interp "let a = 15"
Hello from Z!
Interpreting let a = 15...
Parsing let a = 15...
Parse done.
----- NODE ----
{kind:ND_PROG, exprs: [{kind:ND_LET, name: a, value: {kind: ND_INT, as.num: 15} }]}
----- END ----
Executing ...
------------------
a: 15
15
```

成功了！

不过只做到这一步也没什么用处，因为我们没法去使用这个定量。

下一步，我们要实现`ND_NAME`节点，让它能够在表达式里被使用。

对应的实例是：

```z
let a = 15
a + 5
```

## 定量的使用

至今为止，四则运算里还只能直接用`整数`，所有`Binop`的操作对象都只考虑了整数。

本节我们要加上对`ND_NAME`节点的处理。

在`unary()`里加上对`TK_NAME`的处理：

```c
static Node *unary(Parser *parser) {
  switch (parser->cur->kind) {
    // ...
    case TK_NAME:
        return name(parser);
    // ...
  }
}
```

`name`的处理直接用之前的`fname`改过来就行。

改完之后，发现实际程序根本走不到这个分支来，
调试发现原来是因为现在`expression()`里第一步就判断了`TK_NAME`，然后直接调用`call`分支了。

这是因为之前的Z代码中并没有存量，`TK_NAME`词符只用于函数名，且现在还没有实现把函数调用当做普通的表达式的操作元来处理，因此给它预留了单独的判断分支。

所以现在要把这个分支去掉，把`call`的判断放到`unary`后面去：

```c

// 解析一个表达式
static Node *expr_prec(Parser *parser, Precedence base_prec) {
    // 表达式由一个一元操作开头，后接多层二元操作。

    // 先尝试一元操作
    Node *left = unary(parser);

    // 接着尝试二元操作
    switch (parser->cur->kind) {
    case TK_LPAREN:
        return call(parser, left);
    default:
        return binop(parser, left, base_prec);
    }
}
```

这里的`call`由于它的函数名已经被解析出来了，所以需要增加一个参数传进去。其他地方还和以前一样。

这样，如果表达式只是一个单独的存量名称，那么会在`Node *left = unary(parser)`中解析出来，然后就直接停止解析了。

注意：改成这个写法以后，我还发现了一个遗留的问题，
那就是现在`call`和`binop`并排了，而`call`本质上也是一种二元操作，只不过优先级比四则运算高而已。
这样分开写还是留了一个漏洞：`binop`能够通过递归调用自身，延续不断地向后推进表达式；而`call`只能解析一次就停止了。所以下面的代码就会中断：

```z
add(1, 2) + 3
```

这段代码在解析到`add(1, 2)`时，就会停止解析，后面的`+3`再也没机会了。

要彻底解决这个办法，只有把`call`集成到`binop`一起来统一考虑，即他们都采用二元操作的优先级判断。

经过一番思考，我发现最终优雅的解决办法还是要回到`Pratt解析`。
但这是一个需要整整一节来讲的问题，所以我打算先暂留这个问题，等下一节再单独解决。

现在大家只要知道，`binop`可以递归推进下去，而`call`只能解析一次即可。
换句话说，现在的Z表达式，函数调用只支持单层独立的调用，不能与其他表达式混合使用。

接下来，为了支持`let a = 10; a + 5`这样的表达式，我们需要修改一下`execute()`的逻辑：

```c
// 执行AST
int execute(Node *expr) {
    switch (expr->kind) {
    case ND_PROG:
        int last = 0;
        for (int i = 0; i < expr->as.exprs.count; i++) {
            last = execute(expr->as.exprs.list[i]);
        }
        // 返回最后一个表达式的值
        return last;
    case ND_CALL:
        if (call_builtin(expr)) break;
        if (call_stdlib(expr)) break;
        printf("Unknown function: %s\n", expr->as.call.name->as.str);
        return 0; // 函数调用暂时不返回值
    default:
        int val = eval(expr);
        return val;
    }
    return 0;
}
```

之前每执行一次`execute`就会打印出一个结果，现在改为每行语句的结果都存放在`last`里，并最终返回到上层的`interp`函数中，只打印一次。

这样做的好处，就是实现了“多条语句的返回值是最后一条的值”。

不过现在函数调用的返回值也没有处理，所以会出现`print("hello")`语句的返回值是`0`的情况。
要解决这个问题，首先要解决函数返回值问题，其次还要支持`void`的概念。我打算在完善自定义函数之后再来做。

现在唯一的缺陷就是`print("Hello")`的输出会变成：

```bash
$ xmake run z interp "print(\"Hello\")"
Hello
0
```

最后多了个小尾巴`0`。先忍着吧。

## 存量的查找

现在我们已经支持了定量的声明和使用，但是这两个语句还没联系起来：
“定量的值存到哪里去呢？”

在解释器里，我们需要一个数据结构来存放存量的值，以便于后面的访问。
由于存量是按名字查找的，那么这个数据结构最好是类似于字典或者哈希映射。

对解释器来说，需要两个操作：

```c
// 存入存量的值
void set_val(char *name, int val);

// 获取存量的值
int get_val(char *name);
```

`let a = 10`这个语句会调用`set_val("a", 10)`，
而`a + 5`这个语句会调用`get_val("a")`，得到`10`，再与`5`相加得`15`。

这两个函数需要解决如何真正存储存量值的问题。

我调查了一下，C语言里并没有特别轻量又好用的字典或哈希实现，
而我参考的《Crafting Interpreters》一书里采用的是从零开始自己的实现。

我打算选择后者。但哈希映射的实现本身就是一个较大的话题，上面这本书里也花了整整一章去解决它。
所以我也得另开一节来探讨。

为了快速结束本节，我先用一个最简单的办法来确保上面的用例能通过：

在这一节里，我们约定Z语言只支持一个存量，它就是`a`。

那么实现就非常简单了：

```c
// 用来模拟存量的查找
// 需要用一个hashtable来替代。
static int a = 0;

static void set_val(char *name, int val) {
    a = val;
}

static int get_val(char *name) {
    return a;
}
```

虽然只有一个`a`，但是也确实在解释器里“存放”了，不是吗？

测试一下解释器：

```bash
$ xmake run z interp "let a = 10; a + 5"
...
15
```

成功了！

我给解释器单独加一个用例：

```lua
    add_tests("let", {runargs="let a=10;a+5", trim_output=true, pass_outputs="15"})
```

测试通过！

这一节已经写了不少内容了，先提交一个版本吧：

```bash
$ git commit -a -m "步骤24：解释器支持定量1"
$ git tag -a v0.0.21 -m "步骤24：解释器支持定量1"
$ git push
```


编译器和转译器对存量的处理与解释器有所不同，但似乎都需要类似哈希表的结构来完成名称查找。
所以我打算下一节先自制一个哈希表，之后再来实现编译器和转译器的定量支持。

